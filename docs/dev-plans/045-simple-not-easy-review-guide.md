# DEV-PLAN-045：AI 驱动开发的“简单而非容易”方案评审指引（Simple, Not Easy Review Guide）

**状态**: 规划中（2025-12-26 00:00 UTC）

> 本文档定位：当方案/代码由 AI 辅助生成时，用一套可操作的评审准则，持续把团队从“写得快（Easy）”拉回“结构清晰（Simple）”。本文既适用于设计评审（dev-plan/Spec），也适用于实现评审（PR）。

## 1. 背景与上下文 (Context)
AI 极大降低了“写出来”的门槛，但会诱导我们把复杂度从“显性设计”转移到“隐性耦合”：补丁式堆叠、文件增殖、模式照抄、为让测试通过而引入的防御性分支与死代码。

真正的风险不是“AI 写错”，而是“AI 让我们在不自觉中放弃结构化思考”，把本可简单的系统推向难以理解与难以演化的状态。

## 2. 目标与非目标 (Goals & Non-Goals)
### 2.1 核心目标
- [ ] 在评审中区分：方案是否在追求“简单（Simple）”，还是只是“容易（Easy）”。
- [ ] 把评审从“代码是否能跑”升级为“结构是否清晰、可替换、可演化、可解释”。
- [ ] 让设计评审阶段就能发现“纠缠”与“偶然复杂度”，避免把重构成本推迟到实现后。
- [ ] 提供可复制的评审清单与模板，降低 reviewer 的认知负担（但不降低判断标准）。

### 2.2 非目标
- 不禁止使用 AI；本文关注“产出如何被评审与收敛”，不规定具体的 Prompt 流程。
- 不替代现有质量门禁；命中仓库触发器时仍以 `AGENTS.md` / `Makefile` / CI 为准。

## 3. 核心定义：简单（Simple）vs 容易（Easy）
### 3.1 定义（工作共识）
- **简单（Simple）**：边界清晰、职责单一、依赖方向可预测；同一概念只有一种“权威表达”；关键状态/不变量可被简明解释；变更具有局部性。
- **容易（Easy）**：以最小阻力“把功能塞进去”；通过堆叠分支/复制粘贴/文件增殖来回避设计决策；短期可运行，长期难理解难演化。

### 3.2 快速判断（用于评审开场）
评审者优先问三句话：
1) **边界**：这次改动引入/修改了哪些边界？边界是否清晰到可以被替换？
2) **不变量**：系统必须始终成立的规则是什么？代码/数据/接口如何强制它成立？
3) **可解释**：我能否在 5 分钟内讲清楚主流程 + 失败路径 + 状态机？

## 4. 三阶段评审流程（Research → Plan → Implement）
> 目标：把“结构性问题”前移到 Plan 阶段解决；Implement 阶段只做“对齐检查”。

### 4.1 Stage 1：研究（Research）——拒绝直接写代码
**评审输入（最低要求）**
- [ ] 现状图：关键模块/包/路由/数据流/依赖方向（可用文字或 Mermaid）。
- [ ] 约束清单：必须兼容的历史行为、性能/延迟目标、权限/租户隔离、迁移约束等。
- [ ] 风险点：最可能出错的地方与验证手段（不是“先写再看”）。

**评审关注**
- 是否准确描述现状（而非“看起来像”某种模式）。
- 是否识别出“偶然复杂度”的来源（历史兼容、工具限制、旧接口契约）。

**停止线（任何一项命中则打回）**
- [ ] 方案无法解释“现状为何如此”却直接给出大改动建议。
- [ ] 依赖/边界不清，却已经开始生成大量实现代码。

### 4.2 Stage 2：计划（Plan）——规格驱动，而非对话驱动
**评审输入（建议用 dev-plan/Spec 承载）**
- [ ] 明确的范围：Goals/Non-Goals（防止对话式蔓延）。
- [ ] 结构草图：边界、职责、依赖方向（尽量与 DDD 分层一致）。
- [ ] 契约：接口签名/DTO/错误码/HTMX 行为/数据约束（越精确越好）。
- [ ] 演化路径：分步落地（每步可验证），以及回滚/迁移策略。
- [ ] 验收标准：如何证明“变更是简单的”（不仅是 tests pass）。

**评审关注**
- 计划是否“可执行且确定”：给定同一份 Spec，不应依赖“撞出来”的实现路径。
- 复杂度是否被显式化：困难点是否被拆成可评审的决策，而非留给实现阶段即兴处理。

**停止线**
- [ ] 计划只描述“做什么”，但没有描述“边界/不变量/失败模式/验收方法”。
- [ ] 计划隐含关键决策（例如数据一致性/并发策略/权限模型），却无 ADR 或取舍理由。

### 4.3 Stage 3：实现（Implement）——对齐检查
**评审输入**
- [ ] PR 描述指向对应 Spec/dev-plan，并声明任何偏离点。
- [ ] 关键变更点的可解释性：主流程/状态机/失败路径（以 reviewer 可复述为准）。
- [ ] 验证证据：按触发器矩阵执行的本地校验记录（引用 `AGENTS.md` 入口即可）。

**评审关注**
- 实现是否背离 Stage 2 的计划：AI 是否“自作聪明”发明了新逻辑/新边界/新抽象。
- 是否出现“为让测试通过而写”的分支与兼容层，且没有对应的契约/不变量支撑。

**停止线**
- [ ] 代码新增了未在计划中出现的核心概念（新 service、新模型、新协议）且无合理解释。
- [ ] reviewer 无法解释其工作原理，但作者以“测试过了”作为主要论据。

## 5. 四维评审准则清单（Simple > Easy）
> 使用方式：每个维度至少回答“通过/警告/拒绝”之一，并给出最小修改建议。

### 5.1 结构维度：解耦 vs 纠缠
**容易（警告）**
- [ ] 在核心函数/控制器中不断堆 `if/else`，以补丁方式吸收新需求。
- [ ] 出现 `service2.go/service3.go` 式文件增殖：名字相近、职责重叠、靠“记忆”区分。
- [ ] 同一概念出现多套模型/DTO/错误码/校验路径，缺少权威来源。

**简单（要求）**
- [ ] 边界清晰：模块/组件职责可一句话定义，且能说明输入/输出与不变量。
- [ ] 依赖可预测：替换某模块不需要改动“其他五个地方”（变更局部性）。
- [ ] 抽象克制：接口只暴露必须能力；不为“未来可能”提前引入层级。

**评审问题**
- [ ] 如果我替换/删除这个模块，哪些地方必须改？为什么必须改？
- [ ] 这次引入的新类型/新文件，是“新概念”，还是“旧概念的另一种表达”？

### 5.2 演化维度：规格驱动 vs 对话驱动（Vibe Coding）
**容易（警告）**
- [ ] 方案来自多轮 Prompt 试错与修补；最终代码包含防御性分支/死代码/“为了过测”逻辑。
- [ ] 缺少明确验收标准，评审只能凭“看起来合理”“跑起来没错”判断。

**简单（要求）**
- [ ] 有可审计的 Spec（建议用 dev-plan）：关键决策在文档中明确，而非埋在实现里。
- [ ] 实现严格对齐 Spec 的步骤；偏离必须先更新 Spec，再更新实现。

**评审问题**
- [ ] 哪些行为是契约的一部分？哪些只是实现细节？
- [ ] 如果把作者的实现删掉，另一个人能否仅凭 Spec 重新实现且得到同样结构？

### 5.3 认知维度：本质逻辑 vs 偶然模式
**容易（警告）**
- [ ] AI 机械复刻旧模式（历史兼容、临时 hack、过时封装）作为新功能模板。
- [ ] 复杂度的理由是“代码库一直这么写”，但无法指出对应的业务不变量/约束。

**简单（要求）**
- [ ] 每一段复杂逻辑都能回答：它保护了哪个业务不变量？不这样做会违反什么？
- [ ] 偶然复杂度被隔离：兼容层/临时代码有明确边界与退场计划。

**评审问题**
- [ ] 这段逻辑是“业务必须如此”，还是“历史包袱导致如此”？有没有更直接的表达？
- [ ] 是否存在只服务于工具/框架/旧接口的复杂度？它能否被替换为更小的约束？

### 5.4 维护维度：可理解 vs 仅可运行
**容易（警告）**
- [ ] “测试过了，但说不清怎么工作”：可运行但不可解释，未来维护成本陡增。
- [ ] 需要同时理解过多上下文才能修改（跨多个层/模块/隐式约定）。

**简单（要求）**
- [ ] 上下文压缩：作者能用简洁语言描述状态机、数据流、错误处理路径。
- [ ] 命名与结构让读者“顺着走”：读代码像读一条确定的叙事线，而非跳跃式拼图。

**评审问题**
- [ ] 让作者画出状态机：有哪些状态？由哪些事件驱动？失败如何回退/恢复？
- [ ] 让作者用 10 句话解释主流程；若做不到，优先要求拆分/收敛。

## 6. 快速“简单性”测试（评审时可直接使用）
1) **可替换性测试**：替换一个实现，不应引发跨层级/跨模块连锁修改。
2) **局部性测试**：一个需求变更，应主要影响一个边界内的代码与测试。
3) **叙事测试**：从入口到结果的主流程可被连续描述，不需要频繁“回到上层再跳回”。
4) **不变量测试**：关键规则应由类型/约束/集中校验点承载，而非散落在多处条件分支里。

## 7. 评审模板（可复制到 PR / 设计评审评论）
```md
## Simple > Easy Review（DEV-PLAN-045）

### 结构（解耦/边界）
- [ ] 边界清晰，职责可一句话描述
- [ ] 变更具有局部性；替换模块不需要改动多处
- [ ] 无 service 增殖/重复模型/多套权威表达

### 演化（规格/确定性）
- [ ] 有对应 Spec/dev-plan，并在实现中严格对齐
- [ ] 偏离点已在文档中声明并解释取舍
- [ ] 无“为了过测”而引入的死代码/防御性分支

### 认知（本质/偶然复杂度）
- [ ] 复杂逻辑对应明确业务不变量
- [ ] 历史兼容与临时复杂度被隔离且可退场

### 维护（可理解/可解释）
- [ ] 主流程 + 失败路径 + 状态机可在 5 分钟内解释清楚
- [ ] reviewer 能复述工作原理，而不仅是“看测试绿了”

结论：通过 / 需修改 / 拒绝（原因：...）
```

## 8. 关联 SSOT（避免 drift）
- 触发器矩阵与本地必跑：`AGENTS.md`
- 技术详细设计模板（可执行 Spec）：`docs/dev-plans/001-technical-design-template.md`
- dev-plan 文档规范：`docs/dev-plans/000-docs-format.md`

