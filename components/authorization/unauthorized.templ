package authorization

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/iota-uz/iota-sdk/components/copy_button"
	"github.com/iota-uz/iota-sdk/pkg/composables"
)

func debugURL(subject, object, action, domain, override string) string {
	if override != "" {
		return override
	}
	if subject == "" || object == "" || action == "" {
		return ""
	}
	q := url.Values{}
	q.Set("subject", subject)
	q.Set("object", object)
	q.Set("action", action)
	if domain != "" {
		q.Set("domain", domain)
	}
	return fmt.Sprintf("/core/api/authz/debug?%s", q.Encode())
}

templ requestForm(props RequestFormProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{ _ = templ.URL("") }}
	{{ requestURL := strings.TrimSpace(props.RequestURL) }}
	{{if requestURL == "" {
	requestURL = "/core/api/authz/requests"
}
	}}
	{{ submitLabel := strings.TrimSpace(props.SubmitLabel) }}
	{{if submitLabel == "" {
	submitLabel = pageCtx.T("Authz.Unauthorized.Apply")
}
	}}
	{{ suggestions := parseSuggestedDiff(props.Diff) }}
	<form
		class="space-y-3"
		hx-post={ requestURL }
		hx-target="body"
		hx-swap="none"
		hx-encoding="urlencoded"
		hx-on::after-request="window.handleAuthzRequest && window.handleAuthzRequest(event)"
	>
		<input type="hidden" name="object" value={ props.Object }/>
		<input type="hidden" name="action" value={ props.Action }/>
		<input type="hidden" name="domain" value={ props.Domain }/>
		<input type="hidden" name="subject" value={ props.Subject }/>
		<input type="hidden" name="base_revision" value={ props.BaseRevision }/>
		<input type="hidden" name="request_access" value="true"/>
		<label class="block text-xs font-semibold text-surface-200" for="authz-diff">
			{ pageCtx.T("Authz.Unauthorized.SuggestedDiff") }
		</label>
		<textarea id="authz-diff" name="diff" class="hidden" readonly>{ props.Diff }</textarea>
		<div class="rounded-md border border-surface-400/60 bg-surface-500/30 p-3 space-y-2">
			if len(suggestions) > 0 {
				<table class="w-full table-auto border-collapse text-xs">
					<thead class="border-b border-surface-400/60 text-left text-surface-200">
						<tr>
							<th class="py-1 pr-3 font-medium">{ pageCtx.T("Authz.Domain") }</th>
							<th class="py-1 pr-3 font-medium">{ pageCtx.T("Authz.Object") }</th>
							<th class="py-1 pr-3 font-medium">{ pageCtx.T("Authz.Action") }</th>
							<th class="py-1 font-medium">{ pageCtx.T("Authz.Effect") }</th>
						</tr>
					</thead>
					<tbody class="divide-y divide-surface-400/40 text-surface-50">
						for _, item := range suggestions {
							<tr class="align-top">
								<td class="py-1 pr-3 font-mono">{ item.Domain }</td>
								<td class="py-1 pr-3 font-mono break-all">{ item.Object }</td>
								<td class="py-1 pr-3 font-mono">{ item.Action }</td>
								<td class="py-1 font-mono">{ item.Effect }</td>
							</tr>
						}
					</tbody>
				</table>
			} else {
				<div class="text-xs text-surface-200">{ pageCtx.T("Empty") }</div>
			}
			<div class="flex items-center justify-between gap-2 pt-1">
				<details class="text-xs text-surface-200">
					<summary class="cursor-pointer select-none">{ pageCtx.T("Authz.RequestDetail.RawDiffTitle") }</summary>
					<pre class="mt-2 max-h-44 overflow-auto rounded bg-surface-900/80 p-2 text-[11px] text-surface-50"><code>{ props.Diff }</code></pre>
				</details>
				@copy_button.CopyButton(copy_button.Props{
					Text:    props.Diff,
					Variant: copy_button.VariantMinimal,
					Size:    "14",
					Class:   "!text-surface-200 hover:!text-surface-50",
				})
			</div>
		</div>
		<div class="space-y-2">
			<label class="block text-xs font-semibold text-surface-200" for="authz-reason">
				{ pageCtx.T("Authz.Unauthorized.Reason") }
			</label>
			<input
				id="authz-reason"
				name="reason"
				type="text"
				class="w-full rounded-md border border-surface-400/60 bg-surface-500/40 p-2 text-sm text-white"
				value={ props.Reason }
				required
			/>
		</div>
		<div class="flex flex-wrap items-center gap-3">
			<button
				type="submit"
				class="inline-flex items-center rounded-md bg-primary px-4 py-2 text-sm font-medium text-white hover:bg-primary/90"
			>
				{ submitLabel }
			</button>
			<button
				type="button"
				class="inline-flex items-center rounded-md border border-surface-300/80 px-3 py-2 text-xs font-medium text-surface-50 hover:bg-surface-400/40"
				data-authz-copy-request-id
			>
				{ pageCtx.T("Authz.Unauthorized.CopyRequestID") }
			</button>
		</div>
		<div class="text-xs text-surface-100">
			{ pageCtx.T("Authz.Unauthorized.LastRequest") }：
			<span class="font-mono text-surface-50" data-authz-request-id>{ props.RequestID }</span>
		</div>
	</form>
}

templ Unauthorized(props *UnauthorizedProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{ state := props.State }}
	{{if state == nil {
	state = pageCtx.AuthzState()
}
	}}
	{{ object := strings.ToLower(strings.TrimSpace(props.Object)) }}
	{{ normalizedAction := normalizeAction(props.Action) }}
	{{ operation := strings.TrimSpace(props.Operation) }}
	{{if operation == "" {
	operation = strings.TrimSpace(fmt.Sprintf("%s %s", object, normalizedAction))
	if operation == "" {
		operation = pageCtx.T("Actions")
	}
}
	}}
	{{ subject := resolveSubject(state, props.Subject) }}
	{{ domain := resolveDomain(state, props.Domain) }}
	{{ baseRevision := resolveBaseRevision(ctx, props.BaseRevision) }}
	{{ requestID := strings.TrimSpace(props.RequestID) }}
	{{ policies := normalizePolicies(state, object, normalizedAction) }}
	{{ diffJSON := suggestedDiff(state, policies) }}
	{{ debug := debugURL(subject, object, normalizedAction, domain, strings.TrimSpace(props.DebugURL)) }}
	{{ reason := strings.TrimSpace(props.Reason) }}
	{{if reason == "" {
	reason = pageCtx.T("Authz.Unauthorized.ReasonDefault", map[string]interface{}{"Operation": operation})
}
	}}
	<section
		class="rounded-lg border border-primary bg-surface-600/80 p-6 text-left shadow space-y-4"
		data-authz-container
		data-action={ normalizedAction }
		data-domain={ domain }
		data-object={ object }
		data-request-url="/core/api/authz/requests"
		data-subject={ subject }
		data-debug-url={ debug }
		data-base-revision={ baseRevision }
		data-request-id={ requestID }
		data-sla-unknown={ pageCtx.T("Authz.SLA.Unknown") }
		data-sla-countdown-prefix={ pageCtx.T("Authz.SLA.CountdownPrefix") }
		data-status-unknown-label={ pageCtx.T("Unknown") }
		data-status-pending-review={ pageCtx.T("Authz.Status.PendingReview") }
		data-status-approved={ pageCtx.T("Authz.Status.Approved") }
		data-status-merged={ pageCtx.T("Authz.Status.Merged") }
		data-status-failed={ pageCtx.T("Authz.Status.Failed") }
		data-status-rejected={ pageCtx.T("Authz.Status.Rejected") }
		data-status-canceled={ pageCtx.T("Authz.Status.Canceled") }
		data-status-draft={ pageCtx.T("Authz.Status.Draft") }
		data-toast-error-title={ pageCtx.T("Authz.Toast.ErrorTitle") }
		data-toast-default-error={ pageCtx.T("Authz.Toast.DefaultError") }
		data-toast-stale-title={ pageCtx.T("Authz.Toast.StaleRevisionTitle") }
		data-toast-stale-message={ pageCtx.T("Authz.Toast.StaleRevisionMessage") }
		data-toast-submit-title={ pageCtx.T("Authz.Unauthorized.SubmitSuccess") }
		data-toast-submitted-prefix={ pageCtx.T("Authz.Toast.SubmittedPrefix") }
	>
		<div class="flex items-start justify-between gap-3">
			<div class="space-y-2">
				<h2 class="text-lg font-semibold text-white">
					{ pageCtx.T("Authz.Unauthorized.Title") }
				</h2>
				<p class="text-sm text-surface-100">
					{ pageCtx.T("Authz.Unauthorized._Description", map[string]interface{}{"Operation": operation}) }
				</p>
				<p class="text-xs text-surface-200">
					{ pageCtx.T("Authz.Unauthorized.ApplyDescription") }
				</p>
			</div>
			<div class="text-right text-xs text-surface-200 space-y-1">
				if baseRevision != "" {
					<div>
						{ pageCtx.T("Authz.Unauthorized.BaseRevision") }: <span class="font-mono" data-authz-base-revision>{ baseRevision }</span>
					</div>
				}
				if requestID != "" {
					<div>
						{ pageCtx.T("Authz.Unauthorized.RequestID") }: <span class="font-mono">{ requestID }</span>
					</div>
				}
				if debug != "" {
					<a class="text-primary hover:underline" href={ templ.URL(debug) } target="_blank" rel="noreferrer">
						{ pageCtx.T("Authz.Debug") }
					</a>
				}
			</div>
		</div>
		<div class="rounded-md border border-dashed border-surface-400/60 bg-surface-500/30 p-3">
			if len(policies) > 0 {
				<div class="mb-2 text-xs font-semibold uppercase tracking-wide text-surface-200">
					{ pageCtx.T("Authz.Unauthorized.MissingPolicies") }
				</div>
				<ul class="space-y-2">
					for _, policy := range policies {
						<li class="rounded-md border border-surface-400/60 bg-surface-500/50 p-3 text-xs font-mono text-surface-50">
							{ fmt.Sprintf("%s → %s / %s", policy.Domain, policy.Object, policy.Action) }
						</li>
					}
				</ul>
			} else {
				<p class="text-xs text-surface-200">{ pageCtx.T("Authz.Unauthorized.MissingPolicies") }: { pageCtx.T("Empty") }</p>
			}
		</div>
		@requestForm(RequestFormProps{
			RequestURL:   props.RequestURL,
			Object:       object,
			Action:       normalizedAction,
			Domain:       domain,
			Subject:      subject,
			BaseRevision: baseRevision,
			RequestID:    requestID,
			Diff:         diffJSON,
			Reason:       reason,
		})
		<div class="space-y-2 text-xs text-surface-100" data-authz-status-block>
			<div class="flex items-center gap-2 flex-wrap">
				<span>{ pageCtx.T("Status") }:</span>
				<span class="font-semibold text-white" data-authz-status>{ pageCtx.T("Unknown") }</span>
				<span class="text-surface-200" data-authz-sla>{ pageCtx.T("Authz.SLA.Unknown") }</span>
			</div>
			<div class="flex items-center gap-3 flex-wrap">
				<a
					class="text-primary hover:underline hidden"
					target="_blank"
					rel="noreferrer"
					data-authz-view
				>
					{ pageCtx.T("Authz.Unauthorized.ViewRequest") }
				</a>
				<button
					type="button"
					class="hidden inline-flex items-center rounded-md border border-primary/70 px-3 py-1 text-xs font-medium text-primary hover:bg-primary/10"
					data-authz-retry-bot
				>
					{ pageCtx.T("Authz.Unauthorized.RetryBot") }
				</button>
			</div>
		</div>
		if props.ShowInspector && props.CanDebug {
			@PolicyInspector(&PolicyInspectorProps{
				State:        state,
				Object:       object,
				Action:       normalizedAction,
				Subject:      subject,
				Domain:       domain,
				DebugURL:     debug,
				RequestURL:   props.RequestURL,
				BaseRevision: baseRevision,
				RequestID:    requestID,
				Reason:       props.Reason,
				CanDebug:     props.CanDebug,
			})
		}
		@authzClientScriptOnce.Once() {
			<script>
				(function () {
					if (window.authzRequestWatcher) {
						return;
					}
					const terminalStatuses = new Set(["merged", "failed", "rejected", "canceled"]);
					const cache = new Map();
					const watchers = new Map();

					function isTerminal(status) {
						return terminalStatuses.has((status || "").toLowerCase());
					}

	function statusLabel(status, container) {
		const labels = {
			pending_review: container?.dataset?.statusPendingReview,
			approved: container?.dataset?.statusApproved,
			merged: container?.dataset?.statusMerged,
			failed: container?.dataset?.statusFailed,
			rejected: container?.dataset?.statusRejected,
			canceled: container?.dataset?.statusCanceled,
			draft: container?.dataset?.statusDraft,
		};
		const key = (status || "").toLowerCase();
		return labels[key] || key || container?.dataset?.statusUnknownLabel || "";
	}

					function toastLabels(container) {
						const el = container || document.querySelector("[data-authz-container]");
						const ds = el?.dataset || {};
						return {
							errorTitle: (ds.toastErrorTitle || "").trim(),
							defaultError: (ds.toastDefaultError || "").trim(),
							staleTitle: (ds.toastStaleTitle || "").trim(),
							staleMessage: (ds.toastStaleMessage || "").trim(),
							submitTitle: (ds.toastSubmitTitle || "").trim(),
							submittedPrefix: (ds.toastSubmittedPrefix || "").trim(),
						};
					}

					function parseDetail(detail) {
						let data = detail || {};
						if (typeof data === "string") {
							try {
								data = JSON.parse(data);
							} catch (_) {
								data = {};
							}
						}
						if (data && data.value) {
							return parseDetail(data.value);
						}
						return data || {};
					}

					function normalize(detail) {
						const data = parseDetail(detail);
						if (!data) {
							return null;
						}
						const id = data.id || data.ID || "";
						const status = (data.status || data.Status || "").toLowerCase();
						return {
							id: id,
							status: status,
							updatedAt: data.updated_at || data.updatedAt || data.UpdatedAt,
							estimatedSLA: data.estimated_sla_expires_at || data.EstimatedSLAExpiresAt,
							canRetry: !!(data.can_retry_bot || data.CanRetryBot),
							retryToken: data.retry_token || data.RetryToken,
							viewUrl: data.view_url || data.ViewURL || (id ? "/core/authz/requests/" + id : ""),
						};
					}

					function formatSLA(container, isoString) {
						const unknown = (container?.dataset?.slaUnknown || "").trim();
						const prefix = (container?.dataset?.slaCountdownPrefix || "").trim();
						if (!isoString) {
							return unknown;
						}
						const date = new Date(isoString);
						if (Number.isNaN(date.getTime())) {
							return unknown;
						}
						const diff = date.getTime() - Date.now();
						if (diff <= 0) {
							return unknown;
						}
						const mins = Math.floor(diff / 60000);
						const secs = Math.floor((diff % 60000) / 1000);
						const countdown = String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
						return prefix ? prefix + " " + countdown : countdown;
					}

					function findContainer(id) {
						if (!id) {
							return null;
						}
						return document.querySelector('[data-authz-container][data-request-id="' + id + '"]');
					}

					function render(container, data) {
						if (!container) {
							return;
						}
						const statusEl = container.querySelector("[data-authz-status]");
						if (statusEl) {
			statusEl.textContent = data
				? statusLabel(data.status, container) || container.dataset.statusUnknownLabel || ""
				: container.dataset.statusUnknownLabel || "";
						}
						const slaEl = container.querySelector("[data-authz-sla]");
						if (slaEl) {
							slaEl.textContent = data
								? formatSLA(container, data.estimatedSLA)
								: container.dataset.slaUnknown || "";
						}
						const viewLink = container.querySelector("[data-authz-view]");
						if (viewLink) {
							if (data && data.id) {
								viewLink.href = data.viewUrl || "#";
								viewLink.classList.remove("hidden");
								viewLink.dataset.requestId = data.id;
							} else {
								viewLink.classList.add("hidden");
							}
						}
						const retryBtn = container.querySelector("[data-authz-retry-bot]");
						if (retryBtn) {
							if (data && data.status === "failed" && data.canRetry && data.retryToken) {
								retryBtn.dataset.requestId = data.id;
								retryBtn.dataset.retryToken = data.retryToken;
								retryBtn.classList.remove("hidden");
							} else {
								retryBtn.classList.add("hidden");
							}
						}
						const idEl = container.querySelector("[data-authz-request-id]");
						if (idEl && data && data.id) {
							idEl.textContent = data.id;
						}
					}

					async function fetchRequest(id, opts) {
						const now = Date.now();
						const cached = cache.get(id);
						if (!opts?.force && cached && !isTerminal(cached.status) && now-cached.fetchedAt < 30000) {
							return cached.data;
						}
						const resp = await fetch("/core/api/authz/requests/" + id);
						let payload = null;
						try {
							payload = await resp.json();
						} catch (_) {
							payload = null;
						}
						if (!resp.ok) {
							const labels = toastLabels(null);
							throw payload || { code: resp.status, message: labels.defaultError };
						}
						const data = normalize(payload);
						cache.set(id, { data, fetchedAt: Date.now(), status: data?.status || "" });
						return data;
					}

					function dispatchToast(variant, title, message) {
						window.dispatchEvent(
							new CustomEvent("notify", {
								detail: { variant, title, message },
							}),
						);
					}

					function handleError(err) {
						const detail = normalize(err) || parseDetail(err) || {};
						const code = detail.code || detail.Code || "";
						const container = (detail.meta && detail.meta.request_id) ? findContainer(detail.meta.request_id) : null;
						const labels = toastLabels(container);
						const message = detail.message || detail.Message || labels.defaultError;
						dispatchToast("error", code || labels.errorTitle, message);
						if (detail.meta && detail.meta.base_revision) {
							dispatchToast("warning", labels.staleTitle, labels.staleMessage);
						}
						if (detail.meta && detail.meta.request_id) {
							const retry = container?.querySelector("[data-authz-retry-bot]");
							if (retry) {
								retry.classList.add("hidden");
							}
						}
					}

					function tick(state, force) {
						if (!state || !state.id || state.paused) {
							return;
						}
						const now = Date.now();
						const forceFetch = !!force || state.forceNext || (state.lastFetched > 0 && now - state.lastFetched > 120000);
						state.forceNext = false;
						fetchRequest(state.id, { force: forceFetch })
							.then(function (data) {
								state.lastFetched = Date.now();
								render(state.container, data);
								if (data && isTerminal(data.status) && state.timer) {
									clearInterval(state.timer);
									state.timer = null;
								}
							})
							.catch(handleError);
					}

					function attach(container, id) {
						if (!container || !id) {
							return;
						}
						container.dataset.requestId = id;
						const existing = watchers.get(container) || { lastFetched: 0, paused: false, forceNext: true };
						existing.id = id;
						existing.container = container;
						existing.forceNext = true;
						if (existing.timer) {
							clearInterval(existing.timer);
						}
						existing.timer = setInterval(function () {
							tick(existing, false);
						}, 15000);
						watchers.set(container, existing);
						tick(existing, true);
					}

					function handleUpdate(id, payload) {
						const data = normalize(payload);
						if (data && data.id) {
							cache.set(data.id, { data, fetchedAt: Date.now(), status: data.status || "" });
						}
						const container = findContainer(id);
						if (container) {
							render(container, data);
							attach(container, data?.id || id);
						}
					}

					function handleCreated(event) {
						const detail = normalize(event?.detail);
						if (!detail || !detail.id) {
							return;
						}
						const labels = toastLabels(null);
						const container = findContainer(detail.id) || document.querySelector("[data-authz-container]");
						const slaMsg = detail.estimatedSLA ? formatSLA(container, detail.estimatedSLA) : "";
						const prefix = labels.submittedPrefix;
						const message = slaMsg ? prefix + " " + detail.id + " · " + slaMsg : prefix + " " + detail.id;
						dispatchToast("success", labels.submitTitle, message);
						handleUpdate(detail.id, detail);
					}

					function scan() {
						document.querySelectorAll("[data-authz-container]").forEach(function (container) {
							const id = container.dataset.requestId;
							if (id) {
								attach(container, id);
							}
						});
					}

					window.addEventListener("focus", function () {
						watchers.forEach(function (state) {
							state.paused = false;
							state.forceNext = true;
							tick(state, true);
						});
					});
					window.addEventListener("blur", function () {
						watchers.forEach(function (state) {
							state.paused = true;
						});
					});
					document.addEventListener("authz:request-created", handleCreated);
					document.addEventListener("showErrorToast", function (evt) {
						handleError(parseDetail(evt.detail));
					});
					document.addEventListener("htmx:load", function () {
						scan();
					});
					scan();

					window.authzRequestWatcher = {
						attach: attach,
						handleUpdate: handleUpdate,
						scan: scan,
						handleCreated: handleCreated,
					};
				})();
			</script>
		}
		<script>
			if (!window.handleAuthzRequest) {
				window.handleAuthzRequest = function (evt) {
					if (!evt || !evt.detail || !evt.detail.xhr) {
						return;
					}
					var form = evt.target;
					var xhr = evt.detail.xhr;
					var container = form.closest("[data-authz-container]");
					if (!container) {
						return;
					}
					var baseRev = xhr.getResponseHeader("X-Authz-Base-Revision");
					if (baseRev) {
						container.dataset.baseRevision = baseRev;
						var revInput = form.querySelector('input[name="base_revision"]');
						if (revInput) {
							revInput.value = baseRev;
						}
						var revDisplay = container.querySelector("[data-authz-base-revision]");
						if (revDisplay) {
							revDisplay.textContent = baseRev;
						}
					}
					if (xhr.status < 200 || xhr.status >= 300) {
						return;
					}
					var payload = {};
					try {
						payload = JSON.parse(xhr.responseText || "{}");
					} catch (e) {
						payload = {};
					}
					var requestId = payload.id || payload.request_id || xhr.getResponseHeader("X-Request-ID") || "";
					if (!requestId) {
						return;
					}
					container.dataset.requestId = requestId;
					var requestIdEl = container.querySelector("[data-authz-request-id]");
					if (requestIdEl) {
						requestIdEl.textContent = requestId;
					}
					if (window.authzRequestWatcher) {
						window.authzRequestWatcher.handleUpdate(requestId, payload);
						window.authzRequestWatcher.attach(container, requestId);
					}
				};
				document.addEventListener("click", function (evt) {
					var btn = evt.target.closest("[data-authz-copy-request-id]");
					if (!btn) {
						return;
					}
					var container = btn.closest("[data-authz-container]");
					if (!container) {
						return;
					}
					var requestIdEl = container.querySelector("[data-authz-request-id]");
					if (!requestIdEl) {
						return;
					}
					var text = (requestIdEl.textContent || "").trim();
					if (!text) {
						return;
					}
					if (navigator.clipboard && navigator.clipboard.writeText) {
						navigator.clipboard.writeText(text);
					}
				});
				document.addEventListener("click", function (evt) {
					var retryBtn = evt.target.closest("[data-authz-retry-bot]");
					if (!retryBtn) {
						return;
					}
					var reqId = retryBtn.dataset.requestId;
					var token = retryBtn.dataset.retryToken;
					if (!reqId || !token) {
						return;
					}
					var container = retryBtn.closest("[data-authz-container]");
					var defaultErrorMsg = (container && container.dataset && container.dataset.toastDefaultError) || "";
					retryBtn.disabled = true;
					fetch("/core/api/authz/requests/" + reqId + "/trigger-bot?retry_token=" + encodeURIComponent(token), {
						method: "POST",
					})
						.then(function (resp) {
							return resp
								.json()
								.catch(function () {
									return {};
								})
								.then(function (body) {
									return { ok: resp.ok, body: body };
								});
						})
						.then(function (result) {
							if (!result || !result.ok) {
								if (window.dispatchEvent) {
									window.dispatchEvent(
										new CustomEvent("showErrorToast", {
											detail: result?.body || { code: "E_INTERNAL", message: defaultErrorMsg, meta: { request_id: reqId } },
										}),
									);
								}
								return;
							}
							if (window.authzRequestWatcher) {
								window.authzRequestWatcher.handleUpdate(reqId, result.body);
							}
						})
						.catch(function () {
							if (window.dispatchEvent) {
								window.dispatchEvent(
									new CustomEvent("showErrorToast", {
										detail: { code: "E_INTERNAL", message: defaultErrorMsg, meta: { request_id: reqId } },
									}),
								);
							}
						})
						.finally(function () {
							retryBtn.disabled = false;
						});
				});
			}
		</script>
	</section>
}
