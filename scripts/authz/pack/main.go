package main

import (
	"bufio"
	"crypto/sha256"
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type policyEntry struct {
	raw     string
	sortKey string
}

func main() {
	var (
		dir        = flag.String("dir", "config/access/policies", "directory containing modular policy fragments")
		output     = flag.String("out", "config/access/policy.csv", "path to the aggregated policy file")
		skipHeader = flag.Bool("no-header", false, "skip writing generator header")
		revPath    = flag.String("rev", "", "path to the revision metadata file (defaults to <out>.rev)")
	)
	flag.Parse()

	entries, err := collectEntries(*dir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "authz-pack: %v\n", err)
		os.Exit(1)
	}
	data, err := writeOutput(*output, entries, !*skipHeader)
	if err != nil {
		fmt.Fprintf(os.Stderr, "authz-pack: %v\n", err)
		os.Exit(1)
	}
	if err := writeRevision(metadataPath(*output, *revPath), entries, data); err != nil {
		fmt.Fprintf(os.Stderr, "authz-pack: %v\n", err)
		os.Exit(1)
	}
}

func collectEntries(dir string) ([]policyEntry, error) {
	var files []string
	if err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".csv" {
			return nil
		}
		files = append(files, path)
		return nil
	}); err != nil {
		return nil, err
	}
	sort.Strings(files)

	var entries []policyEntry
	for _, file := range files {
		if err := parsePolicyFile(file, &entries); err != nil {
			return nil, fmt.Errorf("parse %s: %w", file, err)
		}
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i].sortKey < entries[j].sortKey
	})
	return entries, nil
}

func parsePolicyFile(path string, entries *[]policyEntry) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer func() {
		_ = f.Close()
	}()

	scanner := bufio.NewScanner(f)
	lineNumber := 0
	for scanner.Scan() {
		lineNumber++
		raw := strings.TrimSpace(scanner.Text())
		if raw == "" || strings.HasPrefix(raw, "#") {
			continue
		}
		rec, err := parseCSVLine(raw)
		if err != nil {
			return fmt.Errorf("line %d: %w", lineNumber, err)
		}
		key := buildSortKey(rec)
		*entries = append(*entries, policyEntry{
			raw:     strings.Join(rec, ", "),
			sortKey: key,
		})
	}
	return scanner.Err()
}

func parseCSVLine(line string) ([]string, error) {
	reader := csv.NewReader(strings.NewReader(line))
	reader.TrimLeadingSpace = true
	record, err := reader.Read()
	if err != nil {
		return nil, err
	}
	for i := range record {
		record[i] = strings.TrimSpace(record[i])
	}
	return record, nil
}

func buildSortKey(fields []string) string {
	padded := append(fields, "", "", "")
	return strings.Join([]string{
		padded[0],
		padded[1],
		padded[2],
		padded[3],
		padded[4],
	}, "|")
}

func writeOutput(path string, entries []policyEntry, withHeader bool) ([]byte, error) {
	builder := &strings.Builder{}
	if withHeader {
		builder.WriteString("# Code generated by authz-pack. DO NOT EDIT.\n")
	}
	for _, entry := range entries {
		builder.WriteString(entry.raw)
		builder.WriteByte('\n')
	}
	data := []byte(builder.String())
	if err := os.WriteFile(path, data, 0o644); err != nil {
		return nil, err
	}
	return data, nil
}

type revisionMetadata struct {
	Revision    string    `json:"revision"`
	GeneratedAt time.Time `json:"generated_at"`
	Entries     int       `json:"entries"`
}

func writeRevision(path string, entries []policyEntry, policyData []byte) error {
	sum := sha256.Sum256(policyData)
	meta := revisionMetadata{
		Revision:    fmt.Sprintf("%x", sum[:]),
		GeneratedAt: time.Now().UTC(),
		Entries:     len(entries),
	}
	payload, err := json.MarshalIndent(meta, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, payload, 0o644)
}

func metadataPath(output, override string) string {
	if override != "" {
		return override
	}
	return output + ".rev"
}
