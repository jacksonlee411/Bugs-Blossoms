package main

import (
	"bufio"
	"encoding/csv"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type policyEntry struct {
	raw     string
	sortKey string
}

func main() {
	var (
		dir        = flag.String("dir", "config/access/policies", "directory containing modular policy fragments")
		output     = flag.String("out", "config/access/policy.csv", "path to the aggregated policy file")
		skipHeader = flag.Bool("no-header", false, "skip writing generator header")
	)
	flag.Parse()

	entries, err := collectEntries(*dir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "authz-pack: %v\n", err)
		os.Exit(1)
	}
	if err := writeOutput(*output, entries, !*skipHeader); err != nil {
		fmt.Fprintf(os.Stderr, "authz-pack: %v\n", err)
		os.Exit(1)
	}
}

func collectEntries(dir string) ([]policyEntry, error) {
	var files []string
	if err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".csv" {
			return nil
		}
		files = append(files, path)
		return nil
	}); err != nil {
		return nil, err
	}
	sort.Strings(files)

	var entries []policyEntry
	for _, file := range files {
		if err := parsePolicyFile(file, &entries); err != nil {
			return nil, fmt.Errorf("parse %s: %w", file, err)
		}
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i].sortKey < entries[j].sortKey
	})
	return entries, nil
}

func parsePolicyFile(path string, entries *[]policyEntry) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	lineNumber := 0
	for scanner.Scan() {
		lineNumber++
		raw := strings.TrimSpace(scanner.Text())
		if raw == "" || strings.HasPrefix(raw, "#") {
			continue
		}
		rec, err := parseCSVLine(raw)
		if err != nil {
			return fmt.Errorf("line %d: %w", lineNumber, err)
		}
		key := buildSortKey(rec)
		*entries = append(*entries, policyEntry{
			raw:     strings.Join(rec, ", "),
			sortKey: key,
		})
	}
	return scanner.Err()
}

func parseCSVLine(line string) ([]string, error) {
	reader := csv.NewReader(strings.NewReader(line))
	reader.TrimLeadingSpace = true
	record, err := reader.Read()
	if err != nil {
		return nil, err
	}
	for i := range record {
		record[i] = strings.TrimSpace(record[i])
	}
	return record, nil
}

func buildSortKey(fields []string) string {
	padded := append(fields, "", "", "")
	return strings.Join([]string{
		padded[0],
		padded[1],
		padded[2],
		padded[3],
		padded[4],
	}, "|")
}

func writeOutput(path string, entries []policyEntry, withHeader bool) error {
	builder := &strings.Builder{}
	if withHeader {
		builder.WriteString("# Code generated by authz-pack. DO NOT EDIT.\n")
	}
	for _, entry := range entries {
		builder.WriteString(entry.raw)
		builder.WriteByte('\n')
	}
	return os.WriteFile(path, []byte(builder.String()), 0o644)
}
