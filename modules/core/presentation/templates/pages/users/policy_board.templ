package users

import (
	"fmt"
	"net/url"
	"strings"

	icons "github.com/iota-uz/icons/phosphor"
	"github.com/iota-uz/iota-sdk/components/copy_button"
	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/dialog"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/components/base/tab"
	"github.com/iota-uz/iota-sdk/pkg/composables"

	"github.com/iota-uz/iota-sdk/modules/core/presentation/controllers/dtos"
	corecomponents "github.com/iota-uz/iota-sdk/modules/core/presentation/templates/components"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/viewmodels"
)

func displayRoleName(value string) string {
	return strings.TrimPrefix(strings.TrimSpace(value), "role:")
}

func shortenToken(value string) string {
	text := strings.TrimSpace(value)
	if text == "" {
		return ""
	}
	if len(text) <= 28 {
		return text
	}
	return text[:12] + "…" + text[len(text)-8:]
}

func shortenSubject(value string) string {
	text := strings.TrimSpace(value)
	if text == "" {
		return ""
	}
	parts := strings.Split(text, ":")
	if len(parts) < 2 {
		return shortenToken(text)
	}
	parts[len(parts)-1] = shortenToken(parts[len(parts)-1])
	return strings.Join(parts, ":")
}

type UserPolicyRequestStatus struct {
	ID     string
	Status string
	Domain string
	Object string
	Action string
	State  string
}

type UserPolicyEntry struct {
	dtos.PolicyEntryResponse
	StageID         string
	StageKind       string
	Staged          bool
	StageOnly       bool
	RequestID       string
	RequestStatus   string
	RolePoliciesURL string
}

type UserPolicyColumnProps struct {
	Title         string
	Column        string
	Entries       []UserPolicyEntry
	Total         int
	Page          int
	Limit         int
	StageTotal    int
	Subject       string
	Domain        string
	DefaultDomain string
	Type          string
	Search        string
	DomainFilter  string
	ObjectOptions []string
	ActionOptions []string
	RoleOptions   []string
	CanDebug      bool
	CanStage      bool
	BaseURL       string
}

type UserEffectiveRoleSource struct {
	Subject     string
	Chain       []string
	PoliciesURL string
}

type UserEffectivePolicyEntry struct {
	Domain string
	Object string
	Action string
	Effect string
	Direct bool
	Roles  []UserEffectiveRoleSource
}

type UserEffectivePoliciesProps struct {
	Entries       []UserEffectivePolicyEntry
	Total         int
	Page          int
	Limit         int
	DomainFilter  string
	DefaultDomain string
	Search        string
	BaseURL       string
}

type UserPolicyBoardProps struct {
	Subject       string
	DefaultDomain string
	StageTotal    int
	StageSummary  viewmodels.AuthzChangesSummary
	StagePreview  viewmodels.AuthzWorkspacePreview
	Requests      []UserPolicyRequestStatus
	Effective     UserEffectivePoliciesProps
	Inherited     UserPolicyColumnProps
	Direct        UserPolicyColumnProps
	Overrides     UserPolicyColumnProps
	BaseURL       string
	RequestObject string
	RequestAction string
	RequestReason string
	CanStage      bool
	CanRequest    bool
	CanDebug      bool
}

var userPolicyBoardScriptOnce = templ.NewOnceHandle()

func totalPages(total, limit int) int {
	if limit <= 0 {
		return 1
	}
	pages := total / limit
	if total%limit != 0 {
		pages++
	}
	if pages == 0 {
		pages = 1
	}
	return pages
}

templ UserPolicyBoardMeta(label string, value string) {
	if strings.TrimSpace(value) == "" {
		return
	}
	<div class="flex items-center gap-2 rounded-full border border-primary bg-surface-300 px-3 py-1">
		<span class="text-[11px] font-semibold uppercase tracking-wide text-secondary-200">{ label }</span>
		<span class="font-mono text-[12px] text-secondary-100" title={ value }>{ shortenSubject(value) }</span>
		@copy_button.CopyButton(copy_button.Props{
			Text:    value,
			Size:    "14",
			Variant: copy_button.VariantMinimal,
			Class:   "text-secondary-200 hover:text-secondary-50",
		})
	</div>
}

templ UserPolicyBoardAddMenu(canStage bool) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	if !canStage {
		return
	}
	<details class="relative">
		<summary class="list-none">
			<button class="btn btn-xs btn-primary" type="button">
				{ pageCtx.T("Create") }
			</button>
		</summary>
		<ul class="absolute right-0 mt-2 w-56 rounded-md border border-primary bg-surface-300 p-1 text-sm shadow-sm">
			<li>
				<button
					type="button"
					class="w-full rounded-md px-2 py-2 text-left hover:bg-surface-400"
					@click="$dispatch('open-stage-policy-direct')"
				>
					{ pageCtx.T("Users.Permissions.Direct") }
				</button>
			</li>
			<li>
				<button
					type="button"
					class="w-full rounded-md px-2 py-2 text-left hover:bg-surface-400"
					@click="$dispatch('open-stage-policy-overrides')"
				>
					{ pageCtx.T("Users.Permissions.Overrides") }
				</button>
			</li>
		</ul>
	</details>
}

templ UserPolicyBoard(props *UserPolicyBoardProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{boardState, _ := templ.JSONString(map[string]any{
	"subject":  props.Subject,
	"domain":   props.DefaultDomain,
	"requests": props.Requests,
})
	}}
	{{ clearURL := fmt.Sprintf("/core/api/authz/policies/stage?subject=%s", url.QueryEscape(props.Subject)) }}
	{{ filterDomain := props.Effective.DomainFilter }}
	if strings.TrimSpace(filterDomain) == "" {
		{{ filterDomain = props.DefaultDomain }}
	}
	<div
		class="space-y-4"
		id="user-policy-board"
		hx-get={ props.BaseURL }
		hx-trigger="policies:staged from:body"
		hx-target="#user-policy-board"
		hx-swap="outerHTML"
		x-data={ fmt.Sprintf("userPolicyBoardState(%s)", boardState) }
		x-on:authz:request-created.window="onRequestCreated($event)"
		x-init="init()"
		data-status-unknown-label={ pageCtx.T("Unknown") }
		data-status-pending-review={ pageCtx.T("Authz.Status.PendingReview") }
		data-status-approved={ pageCtx.T("Authz.Status.Approved") }
		data-status-merged={ pageCtx.T("Authz.Status.Merged") }
		data-status-failed={ pageCtx.T("Authz.Status.Failed") }
		data-status-rejected={ pageCtx.T("Authz.Status.Rejected") }
		data-status-canceled={ pageCtx.T("Authz.Status.Canceled") }
		data-status-draft={ pageCtx.T("Authz.Status.Draft") }
	>
		<div class="flex items-start justify-between flex-wrap gap-3">
			<div class="space-y-1">
				<h3 class="text-lg font-semibold">{ pageCtx.T("Users.Tabs.Permissions") }</h3>
				<div class="flex flex-wrap gap-2 text-sm text-secondary-300">
					@UserPolicyBoardMeta(pageCtx.T("Authz.Subject"), props.Subject)
					@UserPolicyBoardMeta(pageCtx.T("Authz.Domain"), props.DefaultDomain)
				</div>
			</div>
			<div class="flex items-center gap-2 flex-wrap">
				if props.StageTotal > 0 {
					<span class="text-xs px-2 py-1 rounded-full bg-primary text-primary-foreground border border-primary/70">
						{ fmt.Sprintf(pageCtx.T("Authz.Stage.Badge"), props.StageTotal) }
					</span>
				}
				if !props.CanStage && props.CanRequest {
					<form
						class="flex items-center gap-2"
						hx-post="/core/api/authz/requests"
						hx-target="body"
						hx-swap="none"
						hx-on::before-request="this.querySelector('button').disabled=true;"
						hx-on::after-request="this.querySelector('button').disabled=false;"
					>
						<input type="hidden" name="object" value={ props.RequestObject }/>
						<input type="hidden" name="action" value={ props.RequestAction }/>
						<input type="hidden" name="domain" value={ props.DefaultDomain }/>
						<input type="hidden" name="diff" value="[]"/>
						<input type="hidden" name="request_access" value="1"/>
						<input type="hidden" name="reason" value={ props.RequestReason }/>
						<button class="btn btn-xs btn-primary" type="submit">
							{ pageCtx.T("Authz.Unauthorized.Apply") }
						</button>
					</form>
				} else if !props.CanStage && !props.CanRequest {
					<span class="text-xs text-secondary-200">{ pageCtx.T("Authz.Unauthorized.ApplyHint") }</span>
				} else {
					@UserPolicyBoardAddMenu(props.CanStage)
				}
			</div>
		</div>
		<form
			class="flex flex-wrap items-center gap-2 rounded-lg border border-primary bg-surface-400 p-3 text-sm"
			hx-get={ props.BaseURL }
			hx-target="#user-policy-board"
			hx-swap="outerHTML"
			hx-push-url="true"
			hx-trigger="change from:(form select), keyup delay:400ms from:(form input)"
		>
			@input.Text(&input.Props{
				Placeholder: pageCtx.T("Authz.Domain"),
				Attrs: templ.Attributes{
					"name":  "domain",
					"value": filterDomain,
				},
			})
			@input.Text(&input.Props{
				Placeholder: pageCtx.T("Search"),
				Attrs: templ.Attributes{
					"name":  "q",
					"value": props.Effective.Search,
				},
			})
			<button
				class="btn btn-xs"
				type="button"
				hx-get={ props.BaseURL }
				hx-target="#user-policy-board"
				hx-swap="outerHTML"
				hx-push-url="true"
			>
				{ pageCtx.T("Clear") }
			</button>
		</form>
		<div class="space-y-2 text-xs">
			<div class="text-secondary-200">{ pageCtx.T("Authz.SLA.Expected") }</div>
			<template x-if="requests.length > 0">
				<div class="flex flex-wrap gap-2">
					<template x-for="req in requests" :key="req.id">
						<span class="px-2 py-1 rounded border border-primary text-primary-foreground bg-primary/20" x-text="formatRequest(req)"></span>
					</template>
				</div>
			</template>
			<div x-show="polling" class="text-secondary-100">
				{ pageCtx.T("Authz.SLA.Polling") }
			</div>
			<div
				x-show="timeout"
				class="flex flex-wrap items-center gap-3 rounded-md border border-amber-500/40 bg-amber-900/40 px-3 py-2 text-amber-100"
			>
				<span>{ pageCtx.T("Authz.SLA.Timeout") }</span>
				<div class="flex items-center gap-2">
					<button class="btn btn-xs btn-warning" type="button" @click="retryPolling()">
						{ pageCtx.T("Authz.SLA.Retry") }
					</button>
					<button class="btn btn-xs" type="button" @click="copyRequestId()">
						{ pageCtx.T("Authz.SLA.Copy") }
					</button>
				</div>
			</div>
		</div>
		if !props.CanDebug {
			<div class="rounded-lg border border-dashed border-secondary-400 p-4 text-sm text-secondary-200">
				{ pageCtx.T("Authz.Unauthorized.ApplyHint") }
			</div>
		} else {
			@tab.Root(tab.Props{
				DefaultValue: "effective",
			}) {
				@tab.List(tab.ListProps{}) {
					@tab.Button("effective") { { pageCtx.T("Users.Permissions.Effective") } }
					@tab.Button("direct") { { pageCtx.T("Users.Permissions.Direct") } }
					@tab.Button("overrides") { { pageCtx.T("Users.Permissions.Overrides") } }
					@tab.Button("inherited") { { pageCtx.T("Users.Permissions.Inherited") } }
				}
				<div class="mt-4 space-y-4">
					<div x-show="selectedTab === 'effective'">
						@UserEffectivePolicies(&props.Effective)
					</div>
					<div x-show="selectedTab === 'direct'">
						@UserPolicyColumn(&props.Direct)
					</div>
					<div x-show="selectedTab === 'overrides'">
						@UserPolicyColumn(&props.Overrides)
					</div>
					<div x-show="selectedTab === 'inherited'">
						<div class="rounded-lg border border-dashed border-secondary-400 bg-surface-400 p-4 text-sm text-secondary-200">
							{ pageCtx.T("Users.Permissions.InheritedHint") }
						</div>
						@UserPolicyColumn(&props.Inherited)
					</div>
				</div>
			}
		}
		@corecomponents.AuthzWorkspace(corecomponents.AuthzWorkspaceProps{
			Subject:       props.Subject,
			Domain:        "",
			DisplayDomain: props.DefaultDomain,
			StagedCount:   props.StageTotal,
			Summary:       props.StageSummary,
			Preview:       props.StagePreview,
			SubmitURL:     "/core/api/authz/requests",
			ClearURL:      clearURL,
			RequestObject: props.RequestObject,
			RequestAction: props.RequestAction,
			DefaultReason: props.RequestReason,
		})
	</div>
	@userPolicyBoardScriptOnce.Once() {
		<script>
				function statusLabel(status, container) {
					const labels = {
						pending_review: container?.dataset?.statusPendingReview,
						approved: container?.dataset?.statusApproved,
						merged: container?.dataset?.statusMerged,
					failed: container?.dataset?.statusFailed,
					rejected: container?.dataset?.statusRejected,
					canceled: container?.dataset?.statusCanceled,
					draft: container?.dataset?.statusDraft,
				};
				const key = (status || "").toLowerCase();
				return labels[key] || key || container?.dataset?.statusUnknownLabel || "";
			}

			function normalizeRequests(list) {
				const container = document.getElementById("user-policy-board");
				return (list || []).map((item) => {
					const rawStatus = item.status || item.State || "";
					const statusValue = rawStatus || item.Status || "";
					const label = rawStatus ? statusLabel(rawStatus, container) : statusValue;
					const state = rawStatus;
					return {
						id: item.id || item.ID || "",
						label: label,
						state: state,
						domain: item.domain || item.Domain || "",
						object: item.object || item.Object || "",
						action: item.action || item.Action || "",
					};
				});
			}

			function userPolicyBoardState(opts) {
				return {
					subject: opts?.subject || "",
					domain: opts?.domain || "",
					activeDomain: opts?.domain || "",
					requests: normalizeRequests(opts?.requests || []),
					polling: false,
					timeout: false,
					lastRequestId: "",
					timer: null,
					deadline: null,
					init() {
						const pending = (this.requests || []).find(
							(req) => req.state && !this.isTerminal(req.state),
						);
						if (pending && pending.id) {
							this.lastRequestId = pending.id;
							this.activeDomain = pending.domain || this.domain;
							this.startPolling(pending.id);
						}
						return () => {
							this.stopPolling();
						};
					},
					formatRequest(req) {
						const label = req.label || req.state || "";
						return `${label} · ${req.object || ""}/${req.action || ""} · ${req.id || ""}`;
					},
					onRequestCreated(event) {
						let detail = event?.detail?.value ?? event?.detail ?? {};
						if (typeof detail === "string") {
							try {
								detail = JSON.parse(detail);
							} catch (_) {
								detail = {};
							}
						}
						if (!detail) return;
						const normalized = normalizeRequests([detail])[0];
						if (!normalized || !normalized.id) return;
						this.lastRequestId = normalized.id;
						this.activeDomain = normalized.domain || this.domain;
						this.requests = [normalized].concat(this.requests || []);
						this.startPolling(normalized.id);
					},
					startPolling(id) {
						if (!id) return;
						this.lastRequestId = id;
						this.polling = true;
						this.timeout = false;
						this.deadline = Date.now() + 5 * 60 * 1000;
						this.stopTimer();
						this.timer = setInterval(() => this.poll(), 10000);
						this.poll();
					},
					async poll() {
						if (!this.polling) return;
						if (this.deadline && Date.now() > this.deadline) {
							this.stopTimer();
							this.timeout = true;
							this.polling = false;
							return;
						}
						const params = new URLSearchParams({
							subject: this.subject,
							domain: this.activeDomain || this.domain,
							limit: "10",
							sort: "desc",
						});
						let data;
						try {
							const resp = await fetch(`/core/api/authz/requests?${params.toString()}`);
							if (!resp.ok) return;
							data = await resp.json();
						} catch (_) {
							return;
						}
						const normalized = normalizeRequests(data?.data || []);
						if (normalized.length > 0) {
							this.requests = normalized;
						}
						const latest = normalized.find((item) => item.id === this.lastRequestId);
						const state = latest?.state || latest?.label;
						if (state && this.isTerminal(state)) {
							this.stopTimer();
							this.polling = false;
						}
					},
					retryPolling() {
						if (!this.lastRequestId) return;
						this.timeout = false;
						this.startPolling(this.lastRequestId);
					},
					copyRequestId() {
						if (!this.lastRequestId || !navigator?.clipboard) return;
						navigator.clipboard.writeText(this.lastRequestId);
					},
					stopTimer() {
						if (this.timer) {
							clearInterval(this.timer);
							this.timer = null;
						}
					},
					stopPolling() {
						this.stopTimer();
						this.polling = false;
					},
					isTerminal(status) {
						const value = (status || "").toLowerCase();
						return ["merged", "failed", "rejected", "canceled"].includes(value);
					},
				};
			}

				function userPolicyColumnState() {
					const bulkUndoKey = "__authzBulkUndo";

					function bulkUndoStore() {
						if (!window[bulkUndoKey]) {
							window[bulkUndoKey] = {};
						}
						return window[bulkUndoKey];
					}

					return {
						selected: [],
						undo: null,
						initUndo() {
							const id = this.$el?.id;
							if (!id) return;
							const store = bulkUndoStore();
							const saved = store[id];
							if (!saved) return;
							const maxAgeMs = 2 * 60 * 1000;
							if (saved.ts && Date.now() - saved.ts > maxAgeMs) {
								delete store[id];
								return;
							}
							this.undo = saved;
						},
						undoText() {
							const count = this.undo?.count || (this.undo?.ids?.length || 0);
							const template = this.$el?.dataset?.bulkRemoveUndoHint || "";
							return template.replace("__COUNT__", String(count));
						},
						toggleAll(event) {
							const checked = event.target.checked;
							this.selected = [];
							this.$el.querySelectorAll('input[data-entry]').forEach((input) => {
								if (input.disabled) return;
								input.checked = checked;
								if (checked) {
									this.selected.push(input.value);
								}
							});
						},
						async bulkRemove() {
							const inputs = Array.from(this.$el.querySelectorAll('input[data-entry]:checked'));
							if (!inputs.length) return;
							const confirmTemplate = this.$el?.dataset?.bulkRemoveConfirm || "";
							const confirmText = confirmTemplate.replace("__COUNT__", String(inputs.length));
							if (confirmText && !confirm(confirmText)) {
								return;
							}
							const payload = inputs.map((input) => ({
								type: input.dataset.type,
								subject: input.dataset.subject,
								domain: input.dataset.domain,
								object: input.dataset.object,
								action: input.dataset.action,
								effect: input.dataset.effect,
								stage_kind: "remove",
							}));
							let resp;
							let data;
							try {
								resp = await fetch("/core/api/authz/policies/stage", {
									method: "POST",
									headers: { "Content-Type": "application/json", "HX-Request": "true" },
									body: JSON.stringify(payload),
								});
								if (!resp.ok) return;
								data = await resp.json();
							} catch (_) {
								return;
							}

							this.selected = [];
							const createdIDs = data?.created_ids || data?.createdIds || [];
							if (Array.isArray(createdIDs) && createdIDs.length > 0) {
								const store = bulkUndoStore();
								const id = this.$el?.id;
								const undo = { ids: createdIDs, count: inputs.length, ts: Date.now() };
								this.undo = undo;
								if (id) {
									store[id] = undo;
								}
							}

							const total = data?.total ?? data?.Total ?? 0;
							if (typeof htmx !== "undefined") {
								htmx.trigger(document.body, "policies:staged", { total });
							} else {
								document.body.dispatchEvent(new CustomEvent("policies:staged", { detail: { total } }));
							}
						},
						async undoBulkRemove() {
							const ids = this.undo?.ids || [];
							if (!Array.isArray(ids) || ids.length === 0) return;

							let resp;
							let data;
							try {
								resp = await fetch("/core/api/authz/policies/stage", {
									method: "DELETE",
									headers: { "Content-Type": "application/json", "HX-Request": "true" },
									body: JSON.stringify({ ids }),
								});
								if (!resp.ok) return;
								data = await resp.json();
							} catch (_) {
								return;
							}

							const store = bulkUndoStore();
							const id = this.$el?.id;
							if (id) {
								delete store[id];
							}
							this.undo = null;
							this.selected = [];

							const total = data?.total ?? data?.Total ?? 0;
							if (typeof htmx !== "undefined") {
								htmx.trigger(document.body, "policies:staged", { total });
							} else {
								document.body.dispatchEvent(new CustomEvent("policies:staged", { detail: { total } }));
							}
						},
					};
			}
		</script>
	}
}

templ UserEffectivePolicies(props *UserEffectivePoliciesProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{ baseURL := fmt.Sprintf("%s?column=effective", props.BaseURL) }}
	{{ refreshURL := fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }}
	{{ pages := totalPages(props.Total, props.Limit) }}
	{{ sectionID := "user-policy-effective" }}
	<div
		id={ sectionID }
		class="border border-primary rounded-lg p-3 space-y-3 bg-surface-400"
		hx-get={ refreshURL }
		hx-trigger="policies:staged from:body"
		hx-target={ fmt.Sprintf("#%s", sectionID) }
		hx-swap="outerHTML"
	>
		<div class="flex items-center justify-between gap-3">
			<div class="flex items-center gap-2">
				<h4 class="text-base font-semibold">
					{ pageCtx.T("Users.Permissions.Effective") }
				</h4>
				<span class="text-xs text-secondary-200">
					{ pageCtx.T("Users.Permissions.EffectiveHint") }
				</span>
			</div>
		</div>
		<div class="border border-primary rounded-lg overflow-hidden">
			{{columns := []*base.TableColumn{
	&base.TableColumn{Label: pageCtx.T("Authz.Domain"), Key: "domain"},
	&base.TableColumn{Label: pageCtx.T("Authz.Object"), Key: "object"},
	&base.TableColumn{Label: pageCtx.T("Authz.Action"), Key: "action"},
	&base.TableColumn{Label: pageCtx.T("Authz.Effect"), Key: "effect", Class: "w-28"},
	&base.TableColumn{Label: pageCtx.T("Users.Permissions.Sources"), Key: "sources", Class: "w-56"},
}
			}}
			@base.Table(base.TableProps{
				Columns: columns,
			}) {
				if len(props.Entries) == 0 {
					@base.TableRow(base.TableRowProps{}) {
						@base.TableCell(base.TableCellProps{
							Attrs: templ.Attributes{"colspan": fmt.Sprintf("%d", len(columns))},
						}) {
							<div class="py-4 text-center text-sm text-secondary-400">
								{ pageCtx.T("Empty") }
							</div>
						}
					}
				}
				for idx, entry := range props.Entries {
					@base.TableRow(base.TableRowProps{
						Attrs: templ.Attributes{"class": "border-b border-primary"},
					}) {
						@base.TableCell(base.TableCellProps{}) {
							{ entry.Domain }
						}
					@base.TableCell(base.TableCellProps{}) {
						<span class="font-mono break-all">{ entry.Object }</span>
					}
					@base.TableCell(base.TableCellProps{}) {
						<span class="font-mono break-all">{ entry.Action }</span>
					}
					@base.TableCell(base.TableCellProps{}) {
						{{ effectLabel := entry.Effect }}
						{{if strings.EqualFold(effectLabel, "allow") {
	effectLabel = pageCtx.T("Authz.EffectAllow")
} else if strings.EqualFold(effectLabel, "deny") {
	effectLabel = pageCtx.T("Authz.EffectDeny")
}
							}}
							<span class="font-mono">{ effectLabel }</span>
						}
						@base.TableCell(base.TableCellProps{}) {
							{{ roleCount := len(entry.Roles) }}
							<div class="flex items-center justify-between gap-2">
								<div class="flex flex-wrap items-center gap-2">
									if entry.Direct {
										<span class="text-[11px] px-2 py-0.5 rounded-full border border-primary text-primary">
											{ pageCtx.T("Users.Permissions.Source.Direct") }
										</span>
									}
									if roleCount > 0 {
										<span class="text-[11px] px-2 py-0.5 rounded-full border border-secondary-300 text-secondary-100">
											{ fmt.Sprintf("%d", roleCount) } { pageCtx.T("Roles.Meta.List.Title") }
										</span>
									}
								</div>
								<button
									type="button"
									class="btn btn-xs"
									@click={ fmt.Sprintf("$dispatch('open-effective-sources-%d')", idx) }
									aria-label={ pageCtx.T("Users.Permissions.Sources") }
								>
									@icons.MagnifyingGlass(icons.Props{Size: "16"})
								</button>
							</div>
							@dialog.StdViewDrawer(dialog.StdDrawerProps{
								ID:     fmt.Sprintf("effective-sources-%d", idx),
								Title:  pageCtx.T("Users.Permissions.Sources"),
								Action: fmt.Sprintf("open-effective-sources-%d", idx),
							}) {
								<div class="space-y-4 p-4 text-sm">
									<div class="rounded-md border border-primary bg-surface-400 p-3">
										<div class="text-xs font-semibold uppercase tracking-wide text-secondary-200">
											{ pageCtx.T("Users.Permissions.Effective") }
										</div>
										<div class="mt-2 grid grid-cols-1 gap-2 font-mono text-xs text-secondary-100">
											<div><span class="text-secondary-300">{ pageCtx.T("Authz.Domain") }:</span> { entry.Domain }</div>
											<div><span class="text-secondary-300">{ pageCtx.T("Authz.Object") }:</span> { entry.Object }</div>
											<div><span class="text-secondary-300">{ pageCtx.T("Authz.Action") }:</span> { entry.Action }</div>
											<div><span class="text-secondary-300">{ pageCtx.T("Authz.Effect") }:</span> { entry.Effect }</div>
										</div>
									</div>
									<div class="space-y-2">
										<div class="text-xs font-semibold uppercase tracking-wide text-secondary-200">
											{ pageCtx.T("Users.Permissions.Sources") }
										</div>
										if entry.Direct {
											<div class="rounded-md border border-secondary-300 bg-surface-400 p-3">
												<div class="font-medium">{ pageCtx.T("Users.Permissions.Source.Direct") }</div>
											</div>
										}
										if len(entry.Roles) == 0 {
											<div class="text-sm text-secondary-300">{ pageCtx.T("Empty") }</div>
										} else {
											<div class="space-y-2">
												for _, source := range entry.Roles {
													{{ chainNames := make([]string, 0, len(source.Chain)) }}
													for _, roleSubject := range source.Chain {
														{{ chainNames = append(chainNames, displayRoleName(roleSubject)) }}
													}
													{{ chainLabel := strings.Join(chainNames, " → ") }}
													<div class="rounded-md border border-secondary-300 bg-surface-400 p-3">
														<div class="flex items-center justify-between gap-2">
															<div class="font-medium">{ displayRoleName(source.Subject) }</div>
															if source.PoliciesURL != "" && pageCtx.CanAuthz("core.roles", "view") {
																<a
																	href={ templ.URL(source.PoliciesURL) }
																	class="btn btn-xs"
																	target="_blank"
																	rel="noreferrer"
																>
																	@icons.ArrowSquareOut(icons.Props{Size: "16"})
																</a>
															}
														</div>
														<div class="mt-2 text-xs text-secondary-200">
															{ fmt.Sprintf(pageCtx.T("Users.Permissions.Source.RoleChain"), chainLabel) }
														</div>
													</div>
												}
											</div>
										}
									</div>
								</div>
							}
						}
					}
				}
			}
		</div>
		<div class="flex items-center justify-between text-sm">
			<span>{ fmt.Sprintf(pageCtx.T("Pagination.Status"), props.Page, pages, props.Total) }</span>
			<div class="flex gap-2">
				<button
					class="btn btn-xs"
					disabled?={ props.Page <= 1 }
					hx-get={ fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page-1, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }
					hx-target={ fmt.Sprintf("#%s", sectionID) }
					hx-swap="outerHTML"
				>
					{ pageCtx.T("Pagination.Prev") }
				</button>
				<button
					class="btn btn-xs"
					disabled?={ props.Page >= pages }
					hx-get={ fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page+1, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }
					hx-target={ fmt.Sprintf("#%s", sectionID) }
					hx-swap="outerHTML"
				>
					{ pageCtx.T("Pagination.Next") }
				</button>
			</div>
		</div>
	</div>
}

templ UserPolicyColumn(props *UserPolicyColumnProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{ baseURL := fmt.Sprintf("%s?column=%s", props.BaseURL, url.QueryEscape(props.Column)) }}
	{{ refreshURL := fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }}
	{{ pages := totalPages(props.Total, props.Limit) }}
	{{ columnID := fmt.Sprintf("user-policy-%s", props.Column) }}
	{{ objectListID := fmt.Sprintf("authz-policy-object-options-%s", props.Column) }}
	{{ actionListID := fmt.Sprintf("authz-policy-action-options-%s", props.Column) }}
	{{ roleListID := fmt.Sprintf("authz-policy-role-options-%s", props.Column) }}
	{{ formDomain := props.Domain }}
	if formDomain == "" {
		{{ formDomain = props.DomainFilter }}
	}
	if formDomain == "" {
		{{ formDomain = props.DefaultDomain }}
	}
	{{ canEdit := props.CanStage && props.Column != "inherited" }}
	<div
		id={ columnID }
		class="border border-primary rounded-lg p-3 space-y-3 bg-surface-400"
		hx-get={ refreshURL }
		hx-trigger="policies:staged from:body"
		hx-target={ fmt.Sprintf("#%s", columnID) }
		hx-swap="outerHTML"
		x-data="userPolicyColumnState()"
		x-init="initUndo()"
		data-bulk-remove-confirm={ pageCtx.T("Authz.Stage.BulkRemoveConfirm", map[string]any{"Count": "__COUNT__"}) }
		data-bulk-remove-undo-hint={ pageCtx.T("Authz.Stage.BulkRemoveUndoHint", map[string]any{"Count": "__COUNT__"}) }
	>
		<div class="flex items-center justify-between gap-3">
			<div class="flex items-center gap-2">
				<h4 class="text-base font-semibold">
					switch props.Column {
						case "inherited":
							{ pageCtx.T("Users.Permissions.Inherited") }
						case "direct":
							{ pageCtx.T("Users.Permissions.Direct") }
						default:
							{ pageCtx.T("Users.Permissions.Overrides") }
					}
				</h4>
				if props.StageTotal > 0 {
					<span class="text-[11px] px-2 py-0.5 rounded-full bg-primary text-primary-foreground border border-primary/70">
						{ fmt.Sprintf(pageCtx.T("Authz.Stage.Badge"), props.StageTotal) }
					</span>
				}
				if canEdit {
					<input
						type="checkbox"
						class="checkbox checkbox-xs border-primary bg-surface-500"
						aria-label={ pageCtx.T("Authz.Stage.SelectAll") }
						x-on:change="toggleAll($event)"
					/>
				}
			</div>
			<div class="flex items-center gap-2">
				if canEdit {
					<button
						type="button"
						class="btn btn-xs btn-warning"
						x-show="selected.length > 0"
						@click="bulkRemove()"
					>
						{ pageCtx.T("Authz.Stage.BulkRemove") }
					</button>
				}
			</div>
		</div>
		<div
			x-show="undo && undo.ids && undo.ids.length"
			class="flex flex-wrap items-center justify-between gap-3 rounded-md border border-amber-500/40 bg-amber-900/30 px-3 py-2 text-xs text-amber-100"
			role="status"
			aria-live="polite"
		>
			<span x-text="undoText()"></span>
			<button class="btn btn-xs" type="button" @click="undoBulkRemove()">
				{ pageCtx.T("Authz.Stage.BulkRemoveUndo") }
			</button>
		</div>
		@dialog.StdViewDrawer(dialog.StdDrawerProps{
			ID:     fmt.Sprintf("stage-policy-%s", props.Column),
			Title:  pageCtx.T("Authz.Stage.AddRule"),
			Action: fmt.Sprintf("open-stage-policy-%s", props.Column),
		}) {
			<form
				class="space-y-4 p-4"
				hx-post="/core/api/authz/policies/stage"
				hx-target="body"
				hx-swap="none"
			>
				<input type="hidden" name="type" value={ props.Type }/>
				<input type="hidden" name="subject" value={ props.Subject }/>
				<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
					@input.Text(&input.Props{
						Label: pageCtx.T("Authz.Domain"),
						Attrs: templ.Attributes{
							"name": "domain",
							"value": func() string {
								if props.DomainFilter != "" {
									return props.DomainFilter
								}
								if props.Domain != "" {
									return props.Domain
								}
								return props.DefaultDomain
							}(),
						},
					})
					if props.Type != "g" {
						<div class="space-y-1">
							<label class="text-sm text-secondary-200">{ pageCtx.T("Authz.Effect") }</label>
							<select name="effect" class="select select-sm bg-surface-500 border border-primary text-sm rounded w-full">
								<option value="allow" selected>{ pageCtx.T("Authz.EffectAllow") }</option>
								<option value="deny">{ pageCtx.T("Authz.EffectDeny") }</option>
							</select>
						</div>
					}
				</div>
				if props.Type == "g" {
					@input.Text(&input.Props{
						Label:       pageCtx.T("Authz.Role"),
						Placeholder: "role:core.viewer",
						Attrs: templ.Attributes{
							"name":     "object",
							"required": "true",
							"list":     roleListID,
						},
					})
				} else {
					@input.Text(&input.Props{
						Label:       pageCtx.T("Authz.Object"),
						Placeholder: "core.users",
						Attrs: templ.Attributes{
							"name":     "object",
							"required": "true",
							"list":     objectListID,
						},
					})
					@input.Text(&input.Props{
						Label:       pageCtx.T("Authz.Action"),
						Placeholder: "read",
						Attrs: templ.Attributes{
							"name":     "action",
							"required": "true",
							"list":     actionListID,
						},
					})
				}
				<datalist id={ objectListID }>
					for _, option := range props.ObjectOptions {
						<option value={ option }></option>
					}
				</datalist>
				<datalist id={ actionListID }>
					for _, option := range props.ActionOptions {
						<option value={ option }></option>
					}
				</datalist>
				<datalist id={ roleListID }>
					for _, option := range props.RoleOptions {
						<option value={ option }></option>
					}
				</datalist>
				<div class="flex justify-end gap-2">
					@button.Secondary(button.Props{
						Size: button.SizeSM,
						Attrs: templ.Attributes{
							"type":           "button",
							"formnovalidate": "true",
							"@click":         fmt.Sprintf("$dispatch('open-stage-policy-%s')", props.Column),
						},
					}) {
						{ pageCtx.T("Cancel") }
					}
					@button.Primary(button.Props{
						Size: button.SizeSM,
						Attrs: templ.Attributes{
							"type": "submit",
						},
					}) {
						{ pageCtx.T("Save") }
					}
				</div>
			</form>
		}
		<div class="border border-primary rounded-lg overflow-hidden">
			{{ columns := []*base.TableColumn{} }}
			if canEdit {
				{{ columns = append(columns, &base.TableColumn{Label: "", Key: "select", Class: "w-10"}) }}
			}
			if props.Type == "g" {
				{{columns = append(columns,
	&base.TableColumn{Label: pageCtx.T("Authz.Role"), Key: "role"},
	&base.TableColumn{Label: pageCtx.T("Authz.Domain"), Key: "domain"},
	&base.TableColumn{Label: pageCtx.T("Actions"), Key: "actions", Class: "w-32"},
)
				}}
			} else {
				{{columns = append(columns,
	&base.TableColumn{Label: pageCtx.T("Authz.Type"), Key: "type", Class: "w-14"},
	&base.TableColumn{Label: pageCtx.T("Authz.Subject"), Key: "subject"},
	&base.TableColumn{Label: pageCtx.T("Authz.Domain"), Key: "domain"},
	&base.TableColumn{Label: pageCtx.T("Authz.Object"), Key: "object"},
	&base.TableColumn{Label: pageCtx.T("Authz.Action"), Key: "action"},
	&base.TableColumn{Label: pageCtx.T("Authz.Effect"), Key: "effect", Class: "w-28"},
	&base.TableColumn{Label: pageCtx.T("Actions"), Key: "actions", Class: "w-32"},
)
				}}
			}
			@base.Table(base.TableProps{
				Columns: columns,
			}) {
				if len(props.Entries) == 0 {
					@base.TableRow(base.TableRowProps{}) {
						@base.TableCell(base.TableCellProps{
							Attrs: templ.Attributes{"colspan": fmt.Sprintf("%d", len(columns))},
						}) {
							<div class="py-4 text-center text-sm text-secondary-400">
								{ pageCtx.T("Empty") }
							</div>
						}
					}
				}
				for _, entry := range props.Entries {
					{{ rowClass := "border-b border-primary" }}
					if entry.Staged {
						{{ rowClass = "border-b border-green-500/60 bg-green-900/10" }}
						if entry.StageKind == "remove" {
							{{ rowClass = "border-b border-red-500/60 bg-red-900/10 line-through" }}
						}
					}
					@base.TableRow(base.TableRowProps{
						Attrs: templ.Attributes{"class": rowClass},
					}) {
						if canEdit {
							@base.TableCell(base.TableCellProps{}) {
								<input
									type="checkbox"
									class="checkbox checkbox-xs border-primary bg-surface-500"
									value={ fmt.Sprintf("%s|%s|%s|%s|%s", entry.Type, entry.Subject, entry.Domain, entry.Object, entry.Action) }
									data-entry="1"
									data-type={ entry.Type }
									data-subject={ entry.Subject }
									data-domain={ entry.Domain }
									data-object={ entry.Object }
									data-action={ entry.Action }
									data-effect={ entry.Effect }
									disabled?={ entry.Staged }
									x-model="selected"
								/>
							}
						}
						@base.TableCell(base.TableCellProps{}) {
							if props.Type == "g" {
								<div class="flex items-center gap-2">
									<span class="font-mono" x-tooltip.raw={ entry.Object }>{ displayRoleName(entry.Object) }</span>
									if entry.Staged {
										{{ badgeClass := "text-[11px] px-2 py-0.5 rounded-full border bg-green-700 text-white border-green-500" }}
										if entry.StageKind == "remove" {
											{{ badgeClass = "text-[11px] px-2 py-0.5 rounded-full border bg-red-700 border-red-500 text-white" }}
										}
										<span class={ badgeClass }>
											{ pageCtx.T("Authz.Stage.BadgeShort") }
										</span>
									}
									if entry.RequestStatus != "" {
										<span class="text-[11px] px-2 py-0.5 rounded-full border border-primary text-primary">
											{ entry.RequestStatus }
										</span>
									}
								</div>
							} else {
								{ entry.Type }
							}
						}
						if props.Type != "g" {
							@base.TableCell(base.TableCellProps{}) {
								<span class="font-mono break-all" title={ entry.Subject }>{ shortenSubject(entry.Subject) }</span>
							}
						}
						@base.TableCell(base.TableCellProps{}) {
							<span class="font-mono break-all" title={ entry.Domain }>{ entry.Domain }</span>
						}
						if props.Type != "g" {
							@base.TableCell(base.TableCellProps{}) {
								<span class="font-mono break-all" title={ entry.Object }>{ entry.Object }</span>
							}
							@base.TableCell(base.TableCellProps{}) {
								<span class="font-mono break-all" title={ entry.Action }>{ entry.Action }</span>
							}
							@base.TableCell(base.TableCellProps{}) {
								<div class="flex items-center gap-2">
									{{ effectLabel := entry.Effect }}
									{{if strings.EqualFold(effectLabel, "allow") {
	effectLabel = pageCtx.T("Authz.EffectAllow")
} else if strings.EqualFold(effectLabel, "deny") {
	effectLabel = pageCtx.T("Authz.EffectDeny")
}
									}}
									<span>{ effectLabel }</span>
									if entry.Staged {
										{{ badgeClass := "text-[11px] px-2 py-0.5 rounded-full border bg-green-700 text-white border-green-500" }}
										if entry.StageKind == "remove" {
											{{ badgeClass = "text-[11px] px-2 py-0.5 rounded-full border bg-red-700 border-red-500 text-white" }}
										}
										<span class={ badgeClass }>
											{ pageCtx.T("Authz.Stage.BadgeShort") }
										</span>
									}
									if entry.RequestStatus != "" {
										<span class="text-[11px] px-2 py-0.5 rounded-full border border-primary text-primary">
											{ entry.RequestStatus }
										</span>
									}
								</div>
							}
						}
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes("text-right"),
						}) {
							<div class="flex justify-end gap-2">
								if props.Type == "g" && pageCtx.CanAuthz("core.roles", "view") && entry.RolePoliciesURL != "" {
									<a
										href={ templ.URL(entry.RolePoliciesURL) }
										class="btn btn-xs"
										target="_blank"
										rel="noreferrer"
										aria-label={ pageCtx.T("Users.Permissions.ViewRolePolicies") }
										x-tooltip.raw={ pageCtx.T("Users.Permissions.ViewRolePolicies") }
									>
										@icons.ArrowSquareOut(icons.Props{Size: "16"})
									</a>
								}
								if entry.Staged && canEdit && entry.StageID != "" {
									@button.Secondary(button.Props{
										Size: button.SizeXS,
										Attrs: templ.Attributes{
											"type":      "button",
											"hx-delete": fmt.Sprintf("/core/api/authz/policies/stage?id=%s", url.QueryEscape(entry.StageID)),
											"hx-target": "body",
											"hx-swap":   "none",
										},
									}) {
										{ pageCtx.T("Delete") }
									}
								} else if canEdit && !entry.Staged {
									@button.Secondary(button.Props{
										Size: button.SizeXS,
										Attrs: templ.Attributes{
											"type":      "button",
											"hx-post":   "/core/api/authz/policies/stage",
											"hx-target": "body",
											"hx-swap":   "none",
										},
									}) {
										<input type="hidden" name="type" value={ entry.Type }/>
										<input type="hidden" name="subject" value={ entry.Subject }/>
										<input type="hidden" name="domain" value={ entry.Domain }/>
										<input type="hidden" name="object" value={ entry.Object }/>
										<input type="hidden" name="action" value={ entry.Action }/>
										<input type="hidden" name="effect" value={ entry.Effect }/>
										<input type="hidden" name="stage_kind" value="remove"/>
										{ pageCtx.T("Delete") }
									}
								} else if props.Column == "inherited" {
									<span class="text-xs text-secondary-400">{ pageCtx.T("Users.Permissions.InheritedHintShort") }</span>
								} else {
									<span class="text-xs text-secondary-400">{ pageCtx.T("Authz.Unauthorized.ApplyHint") }</span>
								}
							</div>
						}
					}
				}
			}
		</div>
		<div class="flex items-center justify-between text-sm">
			<span>{ fmt.Sprintf(pageCtx.T("Pagination.Status"), props.Page, pages, props.Total) }</span>
			<div class="flex gap-2">
				<button
					class="btn btn-xs"
					disabled?={ props.Page <= 1 }
					hx-get={ fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page-1, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }
					hx-target={ fmt.Sprintf("#%s", columnID) }
					hx-swap="outerHTML"
				>
					{ pageCtx.T("Pagination.Prev") }
				</button>
				<button
					class="btn btn-xs"
					disabled?={ props.Page >= pages }
					hx-get={ fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page+1, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }
					hx-target={ fmt.Sprintf("#%s", columnID) }
					hx-swap="outerHTML"
				>
					{ pageCtx.T("Pagination.Next") }
				</button>
			</div>
		</div>
	</div>
}
