package users

import (
	"fmt"
	"net/url"

	"github.com/iota-uz/iota-sdk/components/base"
	"github.com/iota-uz/iota-sdk/components/base/button"
	"github.com/iota-uz/iota-sdk/components/base/dialog"
	"github.com/iota-uz/iota-sdk/components/base/input"
	"github.com/iota-uz/iota-sdk/pkg/composables"

	"github.com/iota-uz/iota-sdk/modules/core/presentation/controllers/dtos"
	corecomponents "github.com/iota-uz/iota-sdk/modules/core/presentation/templates/components"
	"github.com/iota-uz/iota-sdk/modules/core/presentation/viewmodels"
)

type UserPolicyRequestStatus struct {
	ID     string
	Status string
	Domain string
	Object string
	Action string
	State  string
}

type UserPolicyEntry struct {
	dtos.PolicyEntryResponse
	StageID       string
	StageKind     string
	Staged        bool
	StageOnly     bool
	RequestID     string
	RequestStatus string
}

type UserPolicyColumnProps struct {
	Title         string
	Column        string
	Entries       []UserPolicyEntry
	Total         int
	Page          int
	Limit         int
	StageTotal    int
	Subject       string
	Domain        string
	DefaultDomain string
	Type          string
	Search        string
	DomainFilter  string
	CanDebug      bool
	CanStage      bool
	BaseURL       string
}

type UserPolicyBoardProps struct {
	Subject       string
	DefaultDomain string
	StageTotal    int
	StageSummary  viewmodels.AuthzChangesSummary
	StagePreview  viewmodels.AuthzWorkspacePreview
	Requests      []UserPolicyRequestStatus
	Inherited     UserPolicyColumnProps
	Direct        UserPolicyColumnProps
	Overrides     UserPolicyColumnProps
	BaseURL       string
	RequestObject string
	RequestAction string
	RequestReason string
	CanStage      bool
	CanRequest    bool
	CanDebug      bool
}

var userPolicyBoardScriptOnce = templ.NewOnceHandle()

func totalPages(total, limit int) int {
	if limit <= 0 {
		return 1
	}
	pages := total / limit
	if total%limit != 0 {
		pages++
	}
	if pages == 0 {
		pages = 1
	}
	return pages
}

templ UserPolicyBoard(props *UserPolicyBoardProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{boardState, _ := templ.JSONString(map[string]any{
	"subject":  props.Subject,
	"domain":   props.DefaultDomain,
	"requests": props.Requests,
})
	}}
	{{ clearURL := fmt.Sprintf("/core/api/authz/policies/stage?subject=%s", url.QueryEscape(props.Subject)) }}
	<div
		class="space-y-4"
		id="user-policy-board"
		hx-get={ props.BaseURL }
		hx-trigger="policies:staged from:body"
		hx-target="#user-policy-board"
		hx-swap="outerHTML"
		x-data={ fmt.Sprintf("userPolicyBoardState(%s)", boardState) }
		x-on:authz:request-created.window="onRequestCreated($event)"
		x-init="init()"
		data-status-unknown-label={ pageCtx.T("Unknown") }
		data-status-pending-review={ pageCtx.T("Authz.Status.PendingReview") }
		data-status-approved={ pageCtx.T("Authz.Status.Approved") }
		data-status-merged={ pageCtx.T("Authz.Status.Merged") }
		data-status-failed={ pageCtx.T("Authz.Status.Failed") }
		data-status-rejected={ pageCtx.T("Authz.Status.Rejected") }
		data-status-canceled={ pageCtx.T("Authz.Status.Canceled") }
		data-status-draft={ pageCtx.T("Authz.Status.Draft") }
	>
		<div class="flex items-start justify-between flex-wrap gap-3">
			<div class="space-y-1">
				<h3 class="text-lg font-semibold">{ pageCtx.T("Users.Tabs.Permissions") }</h3>
				<p class="text-sm text-secondary-300">
					{ fmt.Sprintf("%s: %s · %s: %s", pageCtx.T("Authz.Subject"), props.Subject, pageCtx.T("Authz.Domain"), props.DefaultDomain) }
				</p>
			</div>
			<div class="flex items-center gap-2 flex-wrap">
				if props.StageTotal > 0 {
					<span class="text-xs px-2 py-1 rounded-full bg-primary text-primary-foreground border border-primary/70">
						{ fmt.Sprintf(pageCtx.T("Authz.Stage.Badge"), props.StageTotal) }
					</span>
				}
				if !props.CanStage && props.CanRequest {
					<form
						class="flex items-center gap-2"
						hx-post="/core/api/authz/requests"
						hx-target="body"
						hx-swap="none"
						hx-on::before-request="this.querySelector('button').disabled=true;"
						hx-on::after-request="this.querySelector('button').disabled=false;"
					>
						<input type="hidden" name="object" value={ props.RequestObject }/>
						<input type="hidden" name="action" value={ props.RequestAction }/>
						<input type="hidden" name="domain" value={ props.DefaultDomain }/>
						<input type="hidden" name="diff" value="[]"/>
						<input type="hidden" name="request_access" value="1"/>
						<input type="hidden" name="reason" value={ props.RequestReason }/>
						<button class="btn btn-xs btn-primary" type="submit">
							{ pageCtx.T("Authz.Unauthorized.Apply") }
						</button>
					</form>
				} else {
					<span class="text-xs text-secondary-200">{ pageCtx.T("Authz.Unauthorized.ApplyHint") }</span>
				}
			</div>
		</div>
		<div class="space-y-2 text-xs">
			<div class="text-secondary-200">{ pageCtx.T("Authz.SLA.Expected") }</div>
			<template x-if="requests.length > 0">
				<div class="flex flex-wrap gap-2">
					<template x-for="req in requests" :key="req.id">
						<span class="px-2 py-1 rounded border border-primary text-primary-foreground bg-primary/20" x-text="formatRequest(req)"></span>
					</template>
				</div>
			</template>
			<div x-show="polling" class="text-secondary-100">
				{ pageCtx.T("Authz.SLA.Polling") }
			</div>
			<div
				x-show="timeout"
				class="flex flex-wrap items-center gap-3 rounded-md border border-amber-500/40 bg-amber-900/40 px-3 py-2 text-amber-100"
			>
				<span>{ pageCtx.T("Authz.SLA.Timeout") }</span>
				<div class="flex items-center gap-2">
					<button class="btn btn-xs btn-warning" type="button" @click="retryPolling()">
						{ pageCtx.T("Authz.SLA.Retry") }
					</button>
					<button class="btn btn-xs" type="button" @click="copyRequestId()">
						{ pageCtx.T("Authz.SLA.Copy") }
					</button>
				</div>
			</div>
		</div>
		if !props.CanDebug {
			<div class="rounded-lg border border-dashed border-secondary-400 p-4 text-sm text-secondary-200">
				{ pageCtx.T("Authz.Unauthorized.ApplyHint") }
			</div>
		} else {
			<div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
				@UserPolicyColumn(&props.Inherited)
				@UserPolicyColumn(&props.Direct)
				@UserPolicyColumn(&props.Overrides)
			</div>
		}
		@corecomponents.AuthzWorkspace(corecomponents.AuthzWorkspaceProps{
			Subject:       props.Subject,
			Domain:        "",
			DisplayDomain: props.DefaultDomain,
			StagedCount:   props.StageTotal,
			Summary:       props.StageSummary,
			Preview:       props.StagePreview,
			SubmitURL:     "/core/api/authz/requests",
			ClearURL:      clearURL,
			RequestObject: props.RequestObject,
			RequestAction: props.RequestAction,
			DefaultReason: props.RequestReason,
		})
	</div>
	@userPolicyBoardScriptOnce.Once() {
		<script>
			function statusLabel(status, container) {
				const labels = {
					pending_review: container?.dataset?.statusPendingReview,
					approved: container?.dataset?.statusApproved,
					merged: container?.dataset?.statusMerged,
					failed: container?.dataset?.statusFailed,
					rejected: container?.dataset?.statusRejected,
					canceled: container?.dataset?.statusCanceled,
					draft: container?.dataset?.statusDraft,
				};
				const key = (status || "").toLowerCase();
				return labels[key] || key || container?.dataset?.statusUnknownLabel || "";
			}

			function normalizeRequests(list) {
				const container = document.getElementById("user-policy-board");
				return (list || []).map((item) => {
					const rawStatus = item.status || item.State || "";
					const statusValue = rawStatus || item.Status || "";
					const label = rawStatus ? statusLabel(rawStatus, container) : statusValue;
					const state = rawStatus;
					return {
						id: item.id || item.ID || "",
						label: label,
						state: state,
						domain: item.domain || item.Domain || "",
						object: item.object || item.Object || "",
						action: item.action || item.Action || "",
					};
				});
			}

			function userPolicyBoardState(opts) {
				return {
					subject: opts?.subject || "",
					domain: opts?.domain || "",
					activeDomain: opts?.domain || "",
					requests: normalizeRequests(opts?.requests || []),
					polling: false,
					timeout: false,
					lastRequestId: "",
					timer: null,
					deadline: null,
					init() {
						const pending = (this.requests || []).find(
							(req) => req.state && !this.isTerminal(req.state),
						);
						if (pending && pending.id) {
							this.lastRequestId = pending.id;
							this.activeDomain = pending.domain || this.domain;
							this.startPolling(pending.id);
						}
						return () => {
							this.stopPolling();
						};
					},
					formatRequest(req) {
						const label = req.label || req.state || "";
						return `${label} · ${req.object || ""}/${req.action || ""} · ${req.id || ""}`;
					},
					onRequestCreated(event) {
						let detail = event?.detail?.value ?? event?.detail ?? {};
						if (typeof detail === "string") {
							try {
								detail = JSON.parse(detail);
							} catch (_) {
								detail = {};
							}
						}
						if (!detail) return;
						const normalized = normalizeRequests([detail])[0];
						if (!normalized || !normalized.id) return;
						this.lastRequestId = normalized.id;
						this.activeDomain = normalized.domain || this.domain;
						this.requests = [normalized].concat(this.requests || []);
						this.startPolling(normalized.id);
					},
					startPolling(id) {
						if (!id) return;
						this.lastRequestId = id;
						this.polling = true;
						this.timeout = false;
						this.deadline = Date.now() + 5 * 60 * 1000;
						this.stopTimer();
						this.timer = setInterval(() => this.poll(), 10000);
						this.poll();
					},
					async poll() {
						if (!this.polling) return;
						if (this.deadline && Date.now() > this.deadline) {
							this.stopTimer();
							this.timeout = true;
							this.polling = false;
							return;
						}
						const params = new URLSearchParams({
							subject: this.subject,
							domain: this.activeDomain || this.domain,
							limit: "10",
							sort: "desc",
						});
						let data;
						try {
							const resp = await fetch(`/core/api/authz/requests?${params.toString()}`);
							if (!resp.ok) return;
							data = await resp.json();
						} catch (_) {
							return;
						}
						const normalized = normalizeRequests(data?.data || []);
						if (normalized.length > 0) {
							this.requests = normalized;
						}
						const latest = normalized.find((item) => item.id === this.lastRequestId);
						const state = latest?.state || latest?.label;
						if (state && this.isTerminal(state)) {
							this.stopTimer();
							this.polling = false;
						}
					},
					retryPolling() {
						if (!this.lastRequestId) return;
						this.timeout = false;
						this.startPolling(this.lastRequestId);
					},
					copyRequestId() {
						if (!this.lastRequestId || !navigator?.clipboard) return;
						navigator.clipboard.writeText(this.lastRequestId);
					},
					stopTimer() {
						if (this.timer) {
							clearInterval(this.timer);
							this.timer = null;
						}
					},
					stopPolling() {
						this.stopTimer();
						this.polling = false;
					},
					isTerminal(status) {
						const value = (status || "").toLowerCase();
						return ["merged", "failed", "rejected", "canceled"].includes(value);
					},
				};
			}

			function userPolicyColumnState() {
				return {
					selected: [],
					toggleAll(event) {
						const checked = event.target.checked;
						this.selected = [];
						this.$el.querySelectorAll('input[data-entry]').forEach((input) => {
							if (input.disabled) return;
							input.checked = checked;
							if (checked) {
								this.selected.push(input.value);
							}
						});
					},
					bulkRemove() {
						const inputs = Array.from(this.$el.querySelectorAll('input[data-entry]:checked'));
						if (!inputs.length) return;
						const payload = inputs.map((input) => ({
							type: input.dataset.type,
							subject: input.dataset.subject,
							domain: input.dataset.domain,
							object: input.dataset.object,
							action: input.dataset.action,
							effect: input.dataset.effect,
							stage_kind: "remove",
						}));
						this.selected = [];
						if (typeof htmx !== "undefined") {
							htmx.ajax("POST", "/core/api/authz/policies/stage", {
								headers: { "Content-Type": "application/json" },
								target: "body",
								swap: "none",
								body: JSON.stringify(payload),
							});
						}
					},
				};
			}
		</script>
	}
}

templ UserPolicyColumn(props *UserPolicyColumnProps) {
	{{ pageCtx := composables.UsePageCtx(ctx) }}
	{{ baseURL := fmt.Sprintf("%s?column=%s", props.BaseURL, url.QueryEscape(props.Column)) }}
	{{ refreshURL := fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }}
	{{ pages := totalPages(props.Total, props.Limit) }}
	{{ columnID := fmt.Sprintf("user-policy-%s", props.Column) }}
	{{ formDomain := props.Domain }}
	if formDomain == "" {
		{{ formDomain = props.DomainFilter }}
	}
	if formDomain == "" {
		{{ formDomain = props.DefaultDomain }}
	}
	<div
		id={ columnID }
		class="border border-primary rounded-lg p-3 space-y-3 bg-surface-400"
		hx-get={ refreshURL }
		hx-trigger="policies:staged from:body"
		hx-target={ fmt.Sprintf("#%s", columnID) }
		hx-swap="outerHTML"
		x-data="userPolicyColumnState()"
	>
		<div class="flex items-center justify-between gap-3">
			<div class="flex items-center gap-2">
				<h4 class="text-base font-semibold">
					switch props.Column {
						case "inherited":
							{ pageCtx.T("Users.Permissions.Inherited") }
						case "direct":
							{ pageCtx.T("Users.Permissions.Direct") }
						default:
							{ pageCtx.T("Users.Permissions.Overrides") }
					}
				</h4>
				if props.StageTotal > 0 {
					<span class="text-[11px] px-2 py-0.5 rounded-full bg-primary text-primary-foreground border border-primary/70">
						{ fmt.Sprintf(pageCtx.T("Authz.Stage.Badge"), props.StageTotal) }
					</span>
				}
				if props.CanStage {
					<input
						type="checkbox"
						class="checkbox checkbox-xs border-primary bg-surface-500"
						aria-label={ pageCtx.T("Authz.Stage.SelectAll") }
						x-on:change="toggleAll($event)"
					/>
				}
			</div>
			<div class="flex items-center gap-2">
				if props.CanStage {
					@button.Primary(button.Props{
						Size: button.SizeXS,
						Attrs: templ.Attributes{
							"type":   "button",
							"@click": "$dispatch('open-stage-policy')",
						},
					}) {
						{ pageCtx.T("Create") }
					}
					<button
						type="button"
						class="btn btn-xs btn-warning"
						x-show="selected.length > 0"
						@click="bulkRemove()"
					>
						{ pageCtx.T("Authz.Stage.BulkRemove") }
					</button>
				}
			</div>
		</div>
		<form
			class="flex flex-wrap gap-2 items-center text-sm"
			hx-get={ baseURL }
			hx-target={ fmt.Sprintf("#%s", columnID) }
			hx-swap="outerHTML"
			hx-trigger="change from:(form select), keyup delay:400ms from:(form input)"
		>
			<input type="hidden" name="column" value={ props.Column }/>
			<input type="hidden" name="page" value="1"/>
			<input type="hidden" name="limit" value={ fmt.Sprintf("%d", props.Limit) }/>
			@input.Text(&input.Props{
				Placeholder: pageCtx.T("Authz.Domain"),
				Attrs: templ.Attributes{
					"name": "domain",
					"value": func() string {
						if props.DomainFilter != "" {
							return props.DomainFilter
						}
						if props.Domain != "" {
							return props.Domain
						}
						return props.DefaultDomain
					}(),
				},
			})
			@input.Text(&input.Props{
				Placeholder: pageCtx.T("Search"),
				Attrs: templ.Attributes{
					"name":  "q",
					"value": props.Search,
				},
			})
		</form>
		@dialog.StdViewDrawer(dialog.StdDrawerProps{
			ID:     fmt.Sprintf("stage-policy-%s", props.Column),
			Title:  pageCtx.T("Authz.Stage.AddRule"),
			Action: "open-stage-policy",
		}) {
			<form
				class="space-y-4 p-4"
				hx-post="/core/api/authz/policies/stage"
				hx-target="body"
				hx-swap="none"
			>
				<input type="hidden" name="type" value={ props.Type }/>
				<input type="hidden" name="subject" value={ props.Subject }/>
				<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
					@input.Text(&input.Props{
						Label: pageCtx.T("Authz.Domain"),
						Attrs: templ.Attributes{
							"name": "domain",
							"value": func() string {
								if props.DomainFilter != "" {
									return props.DomainFilter
								}
								if props.Domain != "" {
									return props.Domain
								}
								return props.DefaultDomain
							}(),
						},
					})
					if props.Type != "g" {
						<div class="space-y-1">
							<label class="text-sm text-secondary-200">{ pageCtx.T("Authz.Effect") }</label>
							<select name="effect" class="select select-sm bg-surface-500 border border-primary text-sm rounded w-full">
								<option value="allow" selected>allow</option>
								<option value="deny">deny</option>
							</select>
						</div>
					} else {
						<input type="hidden" name="effect" value="allow"/>
					}
				</div>
				if props.Type == "g" {
					@input.Text(&input.Props{
						Label:       pageCtx.T("Authz.Role"),
						Placeholder: "role:core.viewer",
						Attrs: templ.Attributes{
							"name":     "object",
							"required": "true",
						},
					})
					<input type="hidden" name="action" value="*"/>
				} else {
					@input.Text(&input.Props{
						Label:       pageCtx.T("Authz.Object"),
						Placeholder: "core.users",
						Attrs: templ.Attributes{
							"name":     "object",
							"required": "true",
						},
					})
					@input.Text(&input.Props{
						Label:       pageCtx.T("Authz.Action"),
						Placeholder: "read",
						Attrs: templ.Attributes{
							"name":     "action",
							"required": "true",
						},
					})
				}
				<div class="flex justify-end gap-2">
					@button.Secondary(button.Props{
						Size: button.SizeSM,
						Attrs: templ.Attributes{
							"type":           "button",
							"formnovalidate": "true",
							"@click":         "$dispatch('open-stage-policy')",
						},
					}) {
						{ pageCtx.T("Cancel") }
					}
					@button.Primary(button.Props{
						Size: button.SizeSM,
						Attrs: templ.Attributes{
							"type": "submit",
						},
					}) {
						{ pageCtx.T("Save") }
					}
				</div>
			</form>
		}
		<div class="border border-primary rounded-lg overflow-hidden">
			{{ columns := []*base.TableColumn{} }}
			if props.CanStage {
				{{ columns = append(columns, &base.TableColumn{Label: "", Key: "select", Class: "w-10"}) }}
			}
			if props.Type == "g" {
				{{columns = append(columns,
	&base.TableColumn{Label: pageCtx.T("Authz.Role"), Key: "role"},
	&base.TableColumn{Label: pageCtx.T("Authz.Domain"), Key: "domain"},
	&base.TableColumn{Label: pageCtx.T("Actions"), Key: "actions", Class: "w-32"},
)
				}}
			} else {
				{{columns = append(columns,
	&base.TableColumn{Label: pageCtx.T("Authz.Type"), Key: "type", Class: "w-14"},
	&base.TableColumn{Label: pageCtx.T("Authz.Subject"), Key: "subject"},
	&base.TableColumn{Label: pageCtx.T("Authz.Domain"), Key: "domain"},
	&base.TableColumn{Label: pageCtx.T("Authz.Object"), Key: "object"},
	&base.TableColumn{Label: pageCtx.T("Authz.Action"), Key: "action"},
	&base.TableColumn{Label: pageCtx.T("Authz.Effect"), Key: "effect", Class: "w-28"},
	&base.TableColumn{Label: pageCtx.T("Actions"), Key: "actions", Class: "w-32"},
)
				}}
			}
			@base.Table(base.TableProps{
				Columns: columns,
			}) {
				if len(props.Entries) == 0 {
					@base.TableRow(base.TableRowProps{}) {
						@base.TableCell(base.TableCellProps{
							Attrs: templ.Attributes{"colspan": fmt.Sprintf("%d", len(columns))},
						}) {
							<div class="py-4 text-center text-sm text-secondary-400">
								{ pageCtx.T("Empty") }
							</div>
						}
					}
				}
				for _, entry := range props.Entries {
					{{ rowClass := "border-b border-primary" }}
					if entry.Staged {
						{{ rowClass = "border-b border-green-500/60 bg-green-900/10" }}
						if entry.StageKind == "remove" {
							{{ rowClass = "border-b border-red-500/60 bg-red-900/10 line-through" }}
						}
					}
					@base.TableRow(base.TableRowProps{
						Attrs: templ.Attributes{"class": rowClass},
					}) {
						if props.CanStage {
							@base.TableCell(base.TableCellProps{}) {
								<input
									type="checkbox"
									class="checkbox checkbox-xs border-primary bg-surface-500"
									value={ fmt.Sprintf("%s|%s|%s|%s|%s", entry.Type, entry.Subject, entry.Domain, entry.Object, entry.Action) }
									data-entry="1"
									data-type={ entry.Type }
									data-subject={ entry.Subject }
									data-domain={ entry.Domain }
									data-object={ entry.Object }
									data-action={ entry.Action }
									data-effect={ entry.Effect }
									disabled?={ entry.Staged }
									x-model="selected"
								/>
							}
						}
						@base.TableCell(base.TableCellProps{}) {
							if props.Type == "g" {
								<div class="flex items-center gap-2">
									<span class="font-mono">{ entry.Object }</span>
									if entry.Staged {
										{{ badgeClass := "text-[11px] px-2 py-0.5 rounded-full border bg-green-700 text-white border-green-500" }}
										if entry.StageKind == "remove" {
											{{ badgeClass = "text-[11px] px-2 py-0.5 rounded-full border bg-red-700 border-red-500 text-white" }}
										}
										<span class={ badgeClass }>
											{ pageCtx.T("Authz.Stage.BadgeShort") }
										</span>
									}
									if entry.RequestStatus != "" {
										<span class="text-[11px] px-2 py-0.5 rounded-full border border-primary text-primary">
											{ entry.RequestStatus }
										</span>
									}
								</div>
							} else {
								{ entry.Type }
							}
						}
						if props.Type != "g" {
							@base.TableCell(base.TableCellProps{}) {
								{ entry.Subject }
							}
						}
						@base.TableCell(base.TableCellProps{}) {
							{ entry.Domain }
						}
						if props.Type != "g" {
							@base.TableCell(base.TableCellProps{}) {
								{ entry.Object }
							}
							@base.TableCell(base.TableCellProps{}) {
								{ entry.Action }
							}
							@base.TableCell(base.TableCellProps{}) {
								<div class="flex items-center gap-2">
									<span>{ entry.Effect }</span>
									if entry.Staged {
										{{ badgeClass := "text-[11px] px-2 py-0.5 rounded-full border bg-green-700 text-white border-green-500" }}
										if entry.StageKind == "remove" {
											{{ badgeClass = "text-[11px] px-2 py-0.5 rounded-full border bg-red-700 border-red-500 text-white" }}
										}
										<span class={ badgeClass }>
											{ pageCtx.T("Authz.Stage.BadgeShort") }
										</span>
									}
									if entry.RequestStatus != "" {
										<span class="text-[11px] px-2 py-0.5 rounded-full border border-primary text-primary">
											{ entry.RequestStatus }
										</span>
									}
								</div>
							}
						}
						@base.TableCell(base.TableCellProps{
							Classes: templ.Classes("text-right"),
						}) {
							if entry.Staged && props.CanStage && entry.StageID != "" {
								@button.Secondary(button.Props{
									Size: button.SizeXS,
									Attrs: templ.Attributes{
										"type":      "button",
										"hx-delete": fmt.Sprintf("/core/api/authz/policies/stage?id=%s", url.QueryEscape(entry.StageID)),
										"hx-target": "body",
										"hx-swap":   "none",
									},
								}) {
									{ pageCtx.T("Delete") }
								}
							} else if props.CanStage && !entry.Staged {
								@button.Secondary(button.Props{
									Size: button.SizeXS,
									Attrs: templ.Attributes{
										"type":      "button",
										"hx-post":   "/core/api/authz/policies/stage",
										"hx-target": "body",
										"hx-swap":   "none",
									},
								}) {
									<input type="hidden" name="type" value={ entry.Type }/>
									<input type="hidden" name="subject" value={ entry.Subject }/>
									<input type="hidden" name="domain" value={ entry.Domain }/>
									<input type="hidden" name="object" value={ entry.Object }/>
									<input type="hidden" name="action" value={ entry.Action }/>
									<input type="hidden" name="effect" value={ entry.Effect }/>
									<input type="hidden" name="stage_kind" value="remove"/>
									{ pageCtx.T("Delete") }
								}
							} else {
								<span class="text-xs text-secondary-400">{ pageCtx.T("Authz.Unauthorized.ApplyHint") }</span>
							}
						}
					}
				}
			}
		</div>
		<div class="flex items-center justify-between text-sm">
			<span>{ fmt.Sprintf(pageCtx.T("Pagination.Status"), props.Page, pages, props.Total) }</span>
			<div class="flex gap-2">
				<button
					class="btn btn-xs"
					disabled?={ props.Page <= 1 }
					hx-get={ fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page-1, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }
					hx-target={ fmt.Sprintf("#%s", columnID) }
					hx-swap="outerHTML"
				>
					{ pageCtx.T("Pagination.Prev") }
				</button>
				<button
					class="btn btn-xs"
					disabled?={ props.Page >= pages }
					hx-get={ fmt.Sprintf("%s&page=%d&limit=%d&domain=%s&q=%s", baseURL, props.Page+1, props.Limit, url.QueryEscape(props.DomainFilter), url.QueryEscape(props.Search)) }
					hx-target={ fmt.Sprintf("#%s", columnID) }
					hx-swap="outerHTML"
				>
					{ pageCtx.T("Pagination.Next") }
				</button>
			</div>
		</div>
	</div>
}
