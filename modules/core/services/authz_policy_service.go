package services

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/csv"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	authz "github.com/iota-uz/iota-sdk/pkg/authz"
	authzVersion "github.com/iota-uz/iota-sdk/pkg/authz/version"
)

type PolicyEntry struct {
	Type    string `json:"type"`
	Subject string `json:"subject"`
	Domain  string `json:"domain"`
	Object  string `json:"object"`
	Action  string `json:"action"`
	Effect  string `json:"effect"`
}

type PolicyChange struct {
	StageKind string `json:"stage_kind"`
	PolicyEntry
}

type PolicyApplyResult struct {
	BaseRevision string `json:"base_revision"`
	Revision     string `json:"revision"`
	Added        int    `json:"added"`
	Removed      int    `json:"removed"`
}

type AuthzPolicyService struct {
	policyPath   string
	revisionPath string
	provider     authzVersion.Provider
	mu           sync.Mutex
}

func NewAuthzPolicyService(policyPath string) *AuthzPolicyService {
	path := filepath.Clean(strings.TrimSpace(policyPath))
	revPath := path + ".rev"
	return &AuthzPolicyService{
		policyPath:   path,
		revisionPath: revPath,
		provider:     authzVersion.NewFileProvider(revPath),
	}
}

func (s *AuthzPolicyService) Policies(ctx context.Context) ([]PolicyEntry, error) {
	if s.policyPath == "" {
		return nil, errors.New("policy file path is not configured")
	}
	data, err := os.ReadFile(s.policyPath)
	if err != nil {
		return nil, err
	}
	return parsePolicyEntries(data)
}

func (s *AuthzPolicyService) ApplyAndReload(
	ctx context.Context,
	baseRevision string,
	changes []PolicyChange,
	reload func(context.Context) error,
) (PolicyApplyResult, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if strings.TrimSpace(baseRevision) == "" {
		return PolicyApplyResult{}, errors.New("base_revision is required")
	}
	if reload == nil {
		return PolicyApplyResult{}, errors.New("reload callback is required")
	}

	meta, err := s.provider.Current(ctx)
	if err != nil {
		return PolicyApplyResult{}, err
	}
	if meta.Revision != strings.TrimSpace(baseRevision) {
		return PolicyApplyResult{}, ErrRevisionMismatch
	}

	policyBefore, err := os.ReadFile(s.policyPath)
	if err != nil {
		return PolicyApplyResult{}, err
	}
	revBefore, err := os.ReadFile(s.revisionPath)
	if err != nil {
		return PolicyApplyResult{}, err
	}

	current, err := parsePolicyEntries(policyBefore)
	if err != nil {
		return PolicyApplyResult{}, err
	}
	set := make(map[string]PolicyEntry, len(current))
	for _, entry := range current {
		set[canonicalPolicyLine(entry)] = entry
	}

	added := 0
	removed := 0
	for _, change := range changes {
		normalized, err := normalizeChange(change)
		if err != nil {
			return PolicyApplyResult{}, fmt.Errorf("%w: %v", ErrPolicyApply, err)
		}

		line := canonicalPolicyLine(normalized.PolicyEntry)
		switch normalized.StageKind {
		case "add":
			if _, ok := set[line]; ok {
				continue
			}
			set[line] = normalized.PolicyEntry
			added++
		case "remove":
			if _, ok := set[line]; !ok {
				return PolicyApplyResult{}, fmt.Errorf("%w: entry not found", ErrPolicyApply)
			}
			delete(set, line)
			removed++
		default:
			return PolicyApplyResult{}, fmt.Errorf("%w: stage_kind must be add or remove", ErrPolicyApply)
		}
	}

	lines := make([]string, 0, len(set))
	for line := range set {
		lines = append(lines, line)
	}
	sort.Strings(lines)

	var out bytes.Buffer
	out.WriteString("# Code generated by authz-apply. DO NOT EDIT.\n")
	for _, line := range lines {
		out.WriteString(line)
		out.WriteByte('\n')
	}
	nextPolicy := out.Bytes()

	sum := sha256.Sum256(nextPolicy)
	nextRevision := hex.EncodeToString(sum[:])
	revPayload, err := json.MarshalIndent(authzVersion.Metadata{
		Revision:    nextRevision,
		GeneratedAt: time.Now().UTC(),
		Entries:     len(lines),
	}, "", "  ")
	if err != nil {
		return PolicyApplyResult{}, err
	}
	revPayload = append(revPayload, '\n')

	if err := writeAtomicFile(s.policyPath, nextPolicy); err != nil {
		return PolicyApplyResult{}, err
	}
	if err := writeAtomicFile(s.revisionPath, revPayload); err != nil {
		_ = writeAtomicFile(s.policyPath, policyBefore)
		return PolicyApplyResult{}, err
	}

	if err := reload(ctx); err != nil {
		_ = writeAtomicFile(s.policyPath, policyBefore)
		_ = writeAtomicFile(s.revisionPath, revBefore)
		return PolicyApplyResult{}, err
	}

	return PolicyApplyResult{
		BaseRevision: meta.Revision,
		Revision:     nextRevision,
		Added:        added,
		Removed:      removed,
	}, nil
}

func normalizeChange(change PolicyChange) (PolicyChange, error) {
	result := change
	result.StageKind = strings.ToLower(strings.TrimSpace(result.StageKind))
	if result.StageKind == "" {
		result.StageKind = "add"
	}
	result.Type = strings.ToLower(strings.TrimSpace(result.Type))
	result.Subject = strings.TrimSpace(result.Subject)
	result.Domain = strings.TrimSpace(result.Domain)
	result.Object = strings.TrimSpace(result.Object)
	result.Action = strings.TrimSpace(result.Action)
	result.Effect = strings.ToLower(strings.TrimSpace(result.Effect))

	switch result.Type {
	case "p":
		if result.Subject == "" {
			return PolicyChange{}, errors.New("subject is required")
		}
		if result.Domain == "" {
			return PolicyChange{}, errors.New("domain is required")
		}
		if result.Object == "" {
			return PolicyChange{}, errors.New("object is required")
		}
		if result.Action == "" {
			return PolicyChange{}, errors.New("action is required")
		}
		if result.Effect == "" {
			result.Effect = "allow"
		}
		if result.Effect != "allow" {
			return PolicyChange{}, errors.New("effect must be allow")
		}
		result.Action = authz.NormalizeAction(result.Action)
		return result, nil
	case "g":
		if result.Subject == "" {
			return PolicyChange{}, errors.New("subject is required")
		}
		if result.Domain == "" {
			return PolicyChange{}, errors.New("domain is required")
		}
		if result.Object == "" {
			return PolicyChange{}, errors.New("object is required")
		}
		if result.Effect == "" {
			result.Effect = "allow"
		}
		if result.Effect != "allow" {
			return PolicyChange{}, errors.New("effect must be allow")
		}
		result.Action = "*"
		return result, nil
	default:
		return PolicyChange{}, errors.New("type must be p or g")
	}
}

func parsePolicyEntries(data []byte) ([]PolicyEntry, error) {
	reader := csv.NewReader(bytes.NewReader(data))
	reader.TrimLeadingSpace = true
	reader.FieldsPerRecord = -1

	var entries []PolicyEntry
	line := 0
	for {
		record, err := reader.Read()
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			return nil, err
		}
		line++
		if len(record) == 0 {
			continue
		}
		first := strings.TrimSpace(record[0])
		if first == "" || strings.HasPrefix(first, "#") {
			continue
		}

		typ := strings.ToLower(first)
		switch typ {
		case "p":
			if len(record) < 6 {
				return nil, fmt.Errorf("policy file line %d: invalid p record", line)
			}
			entry := PolicyEntry{
				Type:    "p",
				Subject: strings.TrimSpace(record[1]),
				Object:  strings.TrimSpace(record[2]),
				Action:  authz.NormalizeAction(strings.TrimSpace(record[3])),
				Domain:  strings.TrimSpace(record[4]),
				Effect:  strings.ToLower(strings.TrimSpace(record[5])),
			}
			entries = append(entries, entry)
		case "g":
			if len(record) < 4 {
				return nil, fmt.Errorf("policy file line %d: invalid g record", line)
			}
			entry := PolicyEntry{
				Type:    "g",
				Subject: strings.TrimSpace(record[1]),
				Object:  strings.TrimSpace(record[2]),
				Domain:  strings.TrimSpace(record[3]),
				Action:  "*",
				Effect:  "allow",
			}
			entries = append(entries, entry)
		default:
			return nil, fmt.Errorf("policy file line %d: unsupported policy type %q", line, typ)
		}
	}
	return entries, nil
}

func canonicalPolicyLine(entry PolicyEntry) string {
	switch strings.ToLower(strings.TrimSpace(entry.Type)) {
	case "g":
		return fmt.Sprintf(
			"g, %s, %s, %s",
			strings.TrimSpace(entry.Subject),
			strings.TrimSpace(entry.Object),
			strings.TrimSpace(entry.Domain),
		)
	default:
		return fmt.Sprintf(
			"p, %s, %s, %s, %s, %s",
			strings.TrimSpace(entry.Subject),
			strings.TrimSpace(entry.Object),
			authz.NormalizeAction(strings.TrimSpace(entry.Action)),
			strings.TrimSpace(entry.Domain),
			strings.ToLower(strings.TrimSpace(entry.Effect)),
		)
	}
}

func writeAtomicFile(path string, data []byte) error {
	dir := filepath.Dir(path)
	base := filepath.Base(path)
	tmp, err := os.CreateTemp(dir, base+".tmp-*")
	if err != nil {
		return err
	}
	tmpName := tmp.Name()
	defer func() { _ = os.Remove(tmpName) }()

	if _, err := tmp.Write(data); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Sync(); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Close(); err != nil {
		return err
	}
	return os.Rename(tmpName, path)
}
