// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package changerequests_sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOrgChangeRequestByRequestID = `-- name: GetOrgChangeRequestByRequestID :one
SELECT
    tenant_id,
    id,
    request_id,
    requester_id,
    status,
    payload_schema_version,
    payload,
    notes,
    created_at,
    updated_at
FROM org_change_requests
WHERE tenant_id = $1
  AND request_id = $2
`

type GetOrgChangeRequestByRequestIDParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	RequestID string      `json:"request_id"`
}

func (q *Queries) GetOrgChangeRequestByRequestID(ctx context.Context, arg GetOrgChangeRequestByRequestIDParams) (OrgChangeRequest, error) {
	row := q.db.QueryRow(ctx, getOrgChangeRequestByRequestID, arg.TenantID, arg.RequestID)
	var i OrgChangeRequest
	err := row.Scan(
		&i.TenantID,
		&i.ID,
		&i.RequestID,
		&i.RequesterID,
		&i.Status,
		&i.PayloadSchemaVersion,
		&i.Payload,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOrgChangeRequestsByRequester = `-- name: ListOrgChangeRequestsByRequester :many
SELECT
    tenant_id,
    id,
    request_id,
    requester_id,
    status,
    payload_schema_version,
    payload,
    notes,
    created_at,
    updated_at
FROM org_change_requests
WHERE tenant_id = $1
  AND requester_id = $2
ORDER BY updated_at DESC
`

type ListOrgChangeRequestsByRequesterParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	RequesterID pgtype.UUID `json:"requester_id"`
}

func (q *Queries) ListOrgChangeRequestsByRequester(ctx context.Context, arg ListOrgChangeRequestsByRequesterParams) ([]OrgChangeRequest, error) {
	rows, err := q.db.Query(ctx, listOrgChangeRequestsByRequester, arg.TenantID, arg.RequesterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrgChangeRequest{}
	for rows.Next() {
		var i OrgChangeRequest
		if err := rows.Scan(
			&i.TenantID,
			&i.ID,
			&i.RequestID,
			&i.RequesterID,
			&i.Status,
			&i.PayloadSchemaVersion,
			&i.Payload,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOrgChangeRequest = `-- name: UpsertOrgChangeRequest :one
INSERT INTO org_change_requests (
    tenant_id,
    request_id,
    requester_id,
    status,
    payload_schema_version,
    payload,
    notes
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
ON CONFLICT (tenant_id, request_id) DO UPDATE
SET
    requester_id = EXCLUDED.requester_id,
    status = EXCLUDED.status,
    payload_schema_version = EXCLUDED.payload_schema_version,
    payload = EXCLUDED.payload,
    notes = EXCLUDED.notes,
    updated_at = now()
RETURNING
    tenant_id,
    id,
    request_id,
    requester_id,
    status,
    payload_schema_version,
    payload,
    notes,
    created_at,
    updated_at
`

type UpsertOrgChangeRequestParams struct {
	TenantID             pgtype.UUID `json:"tenant_id"`
	RequestID            string      `json:"request_id"`
	RequesterID          pgtype.UUID `json:"requester_id"`
	Status               string      `json:"status"`
	PayloadSchemaVersion int32       `json:"payload_schema_version"`
	Payload              []byte      `json:"payload"`
	Notes                *string     `json:"notes"`
}

func (q *Queries) UpsertOrgChangeRequest(ctx context.Context, arg UpsertOrgChangeRequestParams) (OrgChangeRequest, error) {
	row := q.db.QueryRow(ctx, upsertOrgChangeRequest,
		arg.TenantID,
		arg.RequestID,
		arg.RequesterID,
		arg.Status,
		arg.PayloadSchemaVersion,
		arg.Payload,
		arg.Notes,
	)
	var i OrgChangeRequest
	err := row.Scan(
		&i.TenantID,
		&i.ID,
		&i.RequestID,
		&i.RequesterID,
		&i.Status,
		&i.PayloadSchemaVersion,
		&i.Payload,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
