// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package employee_sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEmployees = `-- name: CountEmployees :one
SELECT COUNT(*)
FROM employees
WHERE tenant_id = $1
`

func (q *Queries) CountEmployees(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEmployees, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT
    e.id,
    e.tenant_id,
    e.first_name,
    e.last_name,
    e.middle_name,
    e.email,
    e.phone,
    e.salary,
    e.salary_currency_id,
    e.hourly_rate,
    e.coefficient,
    e.avatar_id,
    e.created_at,
    e.updated_at,
    em.primary_language,
    em.secondary_language,
    em.tin,
    em.pin,
    em.notes,
    em.birth_date,
    em.hire_date,
    em.resignation_date
FROM employees e
LEFT JOIN employee_meta em ON e.id = em.employee_id
WHERE e.id = $1
  AND e.tenant_id = $2
`

type GetEmployeeByIDParams struct {
	ID       int32       `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetEmployeeByIDRow struct {
	ID                int32              `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	FirstName         string             `json:"first_name"`
	LastName          string             `json:"last_name"`
	MiddleName        *string            `json:"middle_name"`
	Email             string             `json:"email"`
	Phone             *string            `json:"phone"`
	Salary            pgtype.Numeric     `json:"salary"`
	SalaryCurrencyID  *string            `json:"salary_currency_id"`
	HourlyRate        pgtype.Numeric     `json:"hourly_rate"`
	Coefficient       float64            `json:"coefficient"`
	AvatarID          *int32             `json:"avatar_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PrimaryLanguage   *string            `json:"primary_language"`
	SecondaryLanguage *string            `json:"secondary_language"`
	Tin               *string            `json:"tin"`
	Pin               *string            `json:"pin"`
	Notes             *string            `json:"notes"`
	BirthDate         pgtype.Date        `json:"birth_date"`
	HireDate          pgtype.Date        `json:"hire_date"`
	ResignationDate   pgtype.Date        `json:"resignation_date"`
}

func (q *Queries) GetEmployeeByID(ctx context.Context, arg GetEmployeeByIDParams) (GetEmployeeByIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeByID, arg.ID, arg.TenantID)
	var i GetEmployeeByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.Email,
		&i.Phone,
		&i.Salary,
		&i.SalaryCurrencyID,
		&i.HourlyRate,
		&i.Coefficient,
		&i.AvatarID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PrimaryLanguage,
		&i.SecondaryLanguage,
		&i.Tin,
		&i.Pin,
		&i.Notes,
		&i.BirthDate,
		&i.HireDate,
		&i.ResignationDate,
	)
	return i, err
}

const listEmployeesByTenant = `-- name: ListEmployeesByTenant :many
SELECT
    e.id,
    e.tenant_id,
    e.first_name,
    e.last_name,
    e.middle_name,
    e.email,
    e.phone,
    e.salary,
    e.salary_currency_id,
    e.hourly_rate,
    e.coefficient,
    e.avatar_id,
    e.created_at,
    e.updated_at,
    em.primary_language,
    em.secondary_language,
    em.tin,
    em.pin,
    em.notes,
    em.birth_date,
    em.hire_date,
    em.resignation_date
FROM employees e
LEFT JOIN employee_meta em ON e.id = em.employee_id
WHERE e.tenant_id = $1
ORDER BY e.id
`

type ListEmployeesByTenantRow struct {
	ID                int32              `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	FirstName         string             `json:"first_name"`
	LastName          string             `json:"last_name"`
	MiddleName        *string            `json:"middle_name"`
	Email             string             `json:"email"`
	Phone             *string            `json:"phone"`
	Salary            pgtype.Numeric     `json:"salary"`
	SalaryCurrencyID  *string            `json:"salary_currency_id"`
	HourlyRate        pgtype.Numeric     `json:"hourly_rate"`
	Coefficient       float64            `json:"coefficient"`
	AvatarID          *int32             `json:"avatar_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PrimaryLanguage   *string            `json:"primary_language"`
	SecondaryLanguage *string            `json:"secondary_language"`
	Tin               *string            `json:"tin"`
	Pin               *string            `json:"pin"`
	Notes             *string            `json:"notes"`
	BirthDate         pgtype.Date        `json:"birth_date"`
	HireDate          pgtype.Date        `json:"hire_date"`
	ResignationDate   pgtype.Date        `json:"resignation_date"`
}

func (q *Queries) ListEmployeesByTenant(ctx context.Context, tenantID pgtype.UUID) ([]ListEmployeesByTenantRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesByTenantRow{}
	for rows.Next() {
		var i ListEmployeesByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FirstName,
			&i.LastName,
			&i.MiddleName,
			&i.Email,
			&i.Phone,
			&i.Salary,
			&i.SalaryCurrencyID,
			&i.HourlyRate,
			&i.Coefficient,
			&i.AvatarID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PrimaryLanguage,
			&i.SecondaryLanguage,
			&i.Tin,
			&i.Pin,
			&i.Notes,
			&i.BirthDate,
			&i.HireDate,
			&i.ResignationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesPaginated = `-- name: ListEmployeesPaginated :many
SELECT
    e.id,
    e.tenant_id,
    e.first_name,
    e.last_name,
    e.middle_name,
    e.email,
    e.phone,
    e.salary,
    e.salary_currency_id,
    e.hourly_rate,
    e.coefficient,
    e.avatar_id,
    e.created_at,
    e.updated_at,
    em.primary_language,
    em.secondary_language,
    em.tin,
    em.pin,
    em.notes,
    em.birth_date,
    em.hire_date,
    em.resignation_date
FROM employees e
LEFT JOIN employee_meta em ON e.id = em.employee_id
WHERE e.tenant_id = $1
ORDER BY e.id
LIMIT $3
OFFSET $2
`

type ListEmployeesPaginatedParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	RowOffset int32       `json:"row_offset"`
	RowLimit  int32       `json:"row_limit"`
}

type ListEmployeesPaginatedRow struct {
	ID                int32              `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	FirstName         string             `json:"first_name"`
	LastName          string             `json:"last_name"`
	MiddleName        *string            `json:"middle_name"`
	Email             string             `json:"email"`
	Phone             *string            `json:"phone"`
	Salary            pgtype.Numeric     `json:"salary"`
	SalaryCurrencyID  *string            `json:"salary_currency_id"`
	HourlyRate        pgtype.Numeric     `json:"hourly_rate"`
	Coefficient       float64            `json:"coefficient"`
	AvatarID          *int32             `json:"avatar_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PrimaryLanguage   *string            `json:"primary_language"`
	SecondaryLanguage *string            `json:"secondary_language"`
	Tin               *string            `json:"tin"`
	Pin               *string            `json:"pin"`
	Notes             *string            `json:"notes"`
	BirthDate         pgtype.Date        `json:"birth_date"`
	HireDate          pgtype.Date        `json:"hire_date"`
	ResignationDate   pgtype.Date        `json:"resignation_date"`
}

func (q *Queries) ListEmployeesPaginated(ctx context.Context, arg ListEmployeesPaginatedParams) ([]ListEmployeesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesPaginated, arg.TenantID, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesPaginatedRow{}
	for rows.Next() {
		var i ListEmployeesPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FirstName,
			&i.LastName,
			&i.MiddleName,
			&i.Email,
			&i.Phone,
			&i.Salary,
			&i.SalaryCurrencyID,
			&i.HourlyRate,
			&i.Coefficient,
			&i.AvatarID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PrimaryLanguage,
			&i.SecondaryLanguage,
			&i.Tin,
			&i.Pin,
			&i.Notes,
			&i.BirthDate,
			&i.HireDate,
			&i.ResignationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
